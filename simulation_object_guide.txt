The simulation object should contain a minimum set of objects necessary to carry out the dynamics.
These include:


### Mandatory Components ###
sim.m   The mass of the classical coordinates. Should be a 1-D numpy array with the same length as the total number of
classical coordinates. Any "structure" to the coordinates should be encoded into their ordering and not the shape of the
array.

sim.h   The frequency parameter of the classical coordinates. Can be physically motivated or not. Like sim.m it should
be a 1-D numpy array with the same length as the total number of classical coordinates.

sim.h_q(sim)     The quantum Hamiltonian. A function that when called as sim.h_q(sim) returns a 2-D numpy array describing the
matrix elements of the Hamiltonian of the quantum subsystem.

sim.h_qc(z, sim) The quantum-classical Hamiltonian. A function that when called as sim.h_qc(z, sim) returns a 2-D numpy
array describing the matrix elements of the Hamiltonian of the quantum-classical interaction.

sim.h_c(z, sim) The classical Hamiltonian. A function that when called as sim.h_c(z, sim) returns a float describing
the energy of the classical coordiantes.

sim.dh_c_dz(z, sim)     The gradient of the classical Hamiltonian with respect to z. When called as
sim.dh_c_dz(z, sim) returns a 1-D numpy array where the length is the number of classical oscillators. Each element
gives the component of the gradient corresponding to that coordinate.

sim.dh_c_dzc(z, sim)    The same as above but for the conjugate coordinate.

sim.dh_qc_dz(vec_a, vec_b, z, sim)    The matrix element between vec_a and vec_b of the gradient of the
quantum-classical interaction with respect to z <a|d_{z}H_qc |b>. When called as sim.dh_qc_dz(z, sim) returns a
1-D numpy array where each entry corresponds to the term associated with that coordinate.

sim.dh_qc_dzc(vec_a, vec_b, z, sim)     The same as above but for the conjugate coordinate.

sim.init_classical(sim)     A function that returns the initial z and zc values as 1-D numpy arrays.

sim.psi_db_0 A 1-D numpy array of complex numbers describing the initial wavefunction of the quantum subsystem in
the diabatic basis.

sim.calc_dir A string giving the calculation directory for the output of the simulation.

sim.quantum_observables(sim, rho_db, z)    A function that evaluates the desired observables in terms of the simulation
object and the diabatic density matrix. Returns a list of the observables and a list of strings that are the names of
each observable.

sim.classical observables(sim, z) Same as quantum_observables but for the classical coordinates.



### SH/CSH Components ###
sim.hop(z, delta_z, ev_diff, sim)     The "hopping" function, when called it returns two values,
sim.hop -> z, hopped where z is the updated classical coordinates and hopped is a boolean telling if a
hop has occurred. delta_z is the rescaling direction for z. ev_diff is the energy
difference of the hop.
The simulation object is a class that contains the minimum set of variables and functions needed to carry out a dynamics calculation.
It's attributes can be split into two broad categories: those describing the physical system and those describing the dynamics simulation

state variables:
z_branch: (MF, FSSH, CFSSH) np.array((num_branches, num_classical_oscillators), dtype=complex) complex-valued classical coordinates in each branch
psi_db_branch: (MF, FSSH, CFSSH) np.array((num_branches, num_states), dtype=complex) diabatic wavefunction in each branch
rho_db_mf: (MF) np.array((num_states, num_states), dtype=complex) diabatic density matrix in mean-field corresponding to sum over branches
rho_db_fssh (FSSH, CFSSH (if sim.calc_fssh_obs==True)) diabatic density matrix in FSSH
rho_db_cfssh (CFSSH) diabatic density matrix constructed acording to theory specified with sim.dmat_const



Physical system:
sim.init_classical(seed): np.array((num_classical_oscillators), dtype=complex) A function that generates the initial classical coordinates in a single branch when provided with a random seed (integer value). When provided with seed=None it should generate a random initial classical coordinate using the global seed. 
sim.h_q(): np.array((num_states, num_states), dtype=complex) Hermitian matrix describing the quantum subsystem
sim.h_qc_branch(z_branch): np.array((num_branches, num_states, num_states), dtype=complex) Hermitian matrix describing the quantum-classical interaction
sim.dh_c_dz_branch(z_branch): np.array((num_branches, num_classical_oscillators), dtype=complex) gradient of the classical Hamiltonian with respect to z in each branch
sim.dh_c_dzc_branch(z_branch): np.array((num_branches, num_classical_oscillators), dtype=complex) gradient of the classical Hamiltonian with respect to z* in each branch
sim.dh_qc_dz_branch(psi_a_branch, psi_b_branch, z_branch): np.array((num_branches, num_classical_oscillators), dtype=complex) matrix element between psi_a and psi_b of the gradient of the quantum-classical interaction with respect to z in each branch.
sim.dh_qc_dzc_branch(psi_a_branch, psi_b_branch, z_branch): np.array((num_branches, num_classical_oscillators), dtype=complex) matrix element between psi_a and psi_b of the gradient of the quantum-classical interaction with respect to z* in each branch.
sim.hop(z, delta_z, ev_diff): np.array((num_classical_oscillators), dtype=complex), Boolean A function that carries out the rescaling of classical coordinate z in the direction of delta_z with energy difference ev_diff. Returns the rescaled coordinate and a Boolean that is True if the rescaling was carried out and False if the rescaling was frustrated. This is only needed for surface hopping simulations. 

Simulation settings:
sim.dynamics_method:
    'MF': carry out mean-field dynamics
    'FSSH': carry out fewest-switches surface hopping
    'CFSSH': carry out coherent fewest-switches surface hopping
sim.tmax: maximum simulation time 
sim.dt: output timestep
sim.dt_bath: propagation timestep
sim.sh_deterministic:
    True: calculate density matrix deterministically, sim.num_branches == sim.num_states
    False: claculate density matrix stochastically with sim.num_branches branches. 
sim.dmat_const:
    None: do not construct a density matrix
    0: construct a density matrix in MF and FSSH and construct it using the cheap method in CFSSH (without branch pairs)
    1: CFSSH only, construct the density matrix using the full branch-pair eigenbasis. 
sim.gauge_fix:
    0: ensure the sign of the eigenvectors at subsequent timesteps are the same (appropriate if the Hamiltonian is real-valued)
    1: ensure the sign and phase of the eigenvectors at subsequent timesteps are the same (needed if the Hamiltonian is complex-valued)
    2: ensure the sign and phase of the eigenvectors at every timestep are fixed such that the nonadiabatic couplings are real-valued and consistent with previous timesteps (needed if the gauge rapidly changes, very expensive). 
sim.cfssh_branch_pair_update:
    (needed only when sim.dmat_const == 1)
    0: update branch-pair eigenbasis only when that element of the density matrix is needed 
    1: update branch-pair eigenbasis every output timestep (regardless of if it is used to construct the density matrix)
    2: update branch-pair eigenbasis every propagation timestep
sim.state_vars_list: List of strings corresponding to state variables needed to calculate desired observables 
sim.mf_observables(sim, state_vars): dict
    state_vars: a dictionary containing the variables requested in sim.state_vars_list
sim.fssh_observables(sim, state_vars): dict
    state_vars: a dictionary containing the variables requested in sim.state_vars_list
sim.cfssh_observables(sim, state_vars): dict
    state_vars: a dictionary containing the variables requested in sim.state_vars_list
sim.calc_mf_obs:
    True/False: evaluate sim.mf_observables every output timestep
sim.calc_fssh_obs:
    True/False: evaluate sim.fssh_observables every output timestep
sim.calc_cfssh_obs:
    True/False: evaluate sim.cfssh_observables every output timestep
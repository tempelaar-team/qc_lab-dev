Variables List

Model Object

# Mandatory parameters/functions
model.dt # propagation timestep
model.dt_output # output timestep (integer multiple of dt)
model.tmax # maximum simulation time (integer multiple of dt_output)
model.batch_size # number of simulations to be run simultaneously in a single process
model.num_branches # number of simulation branches
model.num_states # number of quantum states
model.num_classical_coordinates # total number of classical coordinates
model.temp # temperature
model.mass # classical oscillator mass
model.pq_weight # classical oscillator auxiliary weight parameter
model.h_c # classical Hamiltonian
model.h_qc # quantum-classical Hamiltonian
model.h_q # quantum Hamiltonian
model.dh_qc_dzc # dH_qc/dz*
model.dh_qc_dz # dH_qc/dz
model.dh_c_dzc # dH_c/dz*
model.wf_db # initial diabatic wavefunction

# spin-boson model parameters


# MF state variables

state.wf_db # diabatic wavefunction
state.z_coord # complex classical coordinate
state.h_quantum # quantum Hamiltonian
state.quantum_force # quantum force
state.dm_db # diabatic density matrix
state.e_c # classical energy
state.e_q # quantum energy

# FSSH state variables
state.hopping_probs_rand_vals # random values used to determine hopping probability threshold
state.stochastic_sh_rand_vals # random values used to initialize active surface stochastically
state.eigvals # eigenvalues
state.eigvecs # eigenvectors
state.eigvecs_previous # eigenvectors of previous timestep
state.wf_adb # adiabatic wavefunction
state.act_surf_ind_0 # initial active surface indices
state.act_surf_ind # active surface indices
state.act_surf # active surface diagonal of dm_adb
state.dm_adb_0 # initial adiabatic density matrix
state.dm_adb # should this be included? No

# CFSSH state variables
state.wf_db_delta
state.wf_adb_delta
state.branch_phase
state.overlap
state.eigvals_branch_pair
state.eigvecs_branch_pair
state.eigvecs_branch_pair_previous







Design principle:

A function may depend dynamically or statically on both parameters and variables. 
variables are quantities over which the function should be independently evaluatable. In other words,
a function should be considered a programming object that is applied to a quantity that is arbitrary (i.e a variable)
while a parameter is a quantity used in the definition of the function. 

For example, the classical Hamiltonian has the variable z_coord and the parameters model.mass, model.qp_weight.
Gradients of functions always inherit their variables.
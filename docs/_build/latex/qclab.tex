%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{QC Lab}
\date{Apr 03, 2025}
\release{}
\author{Tempelaar Team}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{QC Lab} is a Python package designed for implementing and executing quantum\sphinxhyphen{}classical (QC) dynamics simulations.
It offers an environment for developing physical models and QC algorithms which enables algorithms and models to be combined arbitrarily.
QC Lab comes with a variety of already implemented models and algorithms which we hope encourage new researchers to explore the field of quantum\sphinxhyphen{}classical dynamics. Users that implement their own models and algorithms will have the opportunity to contribute them to QC Lab to form a
growing library of quantum\sphinxhyphen{}classical dynamics tools.

\sphinxAtStartPar
\sphinxstylestrong{QC Lab} is developed and maintained by the Tempelaar Team in the Chemistry Department of Northwestern University in Evanston, Illinois, USA.


\chapter{Capabilities}
\label{\detokenize{index:capabilities}}

\section{Dynamics Algorithms}
\label{\detokenize{index:dynamics-algorithms}}
\sphinxAtStartPar
The following algorithms are implemented making use of the complex\sphinxhyphen{}classical coordinate formalism established in {[}1{]}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Mean\sphinxhyphen{}field (Ehrenfest) dynamics {[}2{]}

\item {} 
\sphinxAtStartPar
Fewest\sphinxhyphen{}switches surface hopping (FSSH) dynamics {[}3{]}

\end{itemize}


\section{Model Systems}
\label{\detokenize{index:model-systems}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Spin\sphinxhyphen{}boson model {[}4{]}

\item {} 
\sphinxAtStartPar
Holstein lattice model {[}5{]}

\item {} 
\sphinxAtStartPar
Fenna\sphinxhyphen{}Matthews\sphinxhyphen{}Olson (FMO) complex {[}6, 7{]}

\end{itemize}


\chapter{Installing qc\_lab}
\label{\detokenize{index:installing-qc-lab}}
\sphinxAtStartPar
This alpha release of QC Lab can be installed from source by downloading the repository and executing.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{n}{e} \PYG{o}{.}\PYG{o}{/}
\end{sphinxVerbatim}

\sphinxAtStartPar
from inside its topmost directory (where the \sphinxtitleref{setup.py} file is located).


\chapter{User Guide}
\label{\detokenize{index:user-guide}}
\sphinxAtStartPar
A guide for using models and algorithms that are shipped with QC Lab.

\sphinxstepscope


\section{User Guide}
\label{\detokenize{user_guide/index:user-guide}}\label{\detokenize{user_guide/index:index}}\label{\detokenize{user_guide/index::doc}}
\sphinxstepscope


\subsection{Quick Start Guide}
\label{\detokenize{user_guide/quickstart/quickstart:quick-start-guide}}\label{\detokenize{user_guide/quickstart/quickstart:quickstart}}\label{\detokenize{user_guide/quickstart/quickstart::doc}}
\sphinxAtStartPar
QC Lab is organized into models and algorithms which are combined into a simulation object.
The simulation object fully defines a quantum\sphinxhyphen{}classical dynamics simulation which is then carried out by a dynamics driver.
This guide will walk you through the process of setting up a simulation object and running a simulation.

\sphinxAtStartPar
The code in this page is implemented in the notebook \sphinxtitleref{quickstart.ipynb} which can be found in the \sphinxtitleref{examples} directory of the repository.


\subsubsection{Importing Modules}
\label{\detokenize{user_guide/quickstart/quickstart:importing-modules}}
\sphinxAtStartPar
First, we import the necessary modules.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation} \PYG{c+c1}{\PYGZsh{} import simulation class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{SpinBoson} \PYG{c+c1}{\PYGZsh{} import model class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{MeanField} \PYG{c+c1}{\PYGZsh{} import algorithm class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver} \PYG{c+c1}{\PYGZsh{} import dynamics driver}
\end{sphinxVerbatim}


\subsubsection{Instantiating Simulation Object}
\label{\detokenize{user_guide/quickstart/quickstart:instantiating-simulation-object}}
\sphinxAtStartPar
Next, we instantiate a simulation object from \sphinxtitleref{qc\_lab.Simulation}. Each object has a set of default settings which can be accessed by calling \sphinxtitleref{sim.default\_settings}.
Passing a dictionary to the simulation object when instantiating it will override the default settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default simulation settings: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{default\PYGZus{}settings}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} default simulation settings:  \PYGZob{}\PYGZsq{}tmax\PYGZsq{}: 10, \PYGZsq{}dt\PYGZsq{}: 0.01, \PYGZsq{}dt\PYGZus{}output\PYGZsq{}: 0.1, \PYGZsq{}num\PYGZus{}trajs\PYGZsq{}: 10, \PYGZsq{}batch\PYGZus{}size\PYGZsq{}: 1\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively, you can directly modify the simulation settings by assigning new values to the settings attribute of the simulation object. Here we change the number
of trajectories that the simulation will run, and how many trajectories are run at a time (the batch size). We also change the total time of each trajectory (\sphinxtitleref{tmax}) and the
timestep used for propagation (\sphinxtitleref{dt}).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
QC Lab expects that the total time of the simulation (\sphinxtitleref{tmax}) is an integer multiple of the output timestep (\sphinxtitleref{dt\_output}), which must also be an integer multiple
of the propagation timestep (\sphinxtitleref{dt}).
\end{sphinxadmonition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} change settings to customize simulation}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{num\PYGZus{}trajs} \PYG{o}{=} \PYG{l+m+mi}{200}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mi}{30}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{dt\PYGZus{}output} \PYG{o}{=} \PYG{l+m+mf}{0.1}
\end{sphinxVerbatim}


\subsubsection{Instantiating Model Object}
\label{\detokenize{user_guide/quickstart/quickstart:instantiating-model-object}}
\sphinxAtStartPar
Next, we instantiate a model object. Like the simulation object, it has a set of default constants.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{SpinBoson}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default model constants: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} default model constants:  \PYGZob{}\PYGZsq{}temp\PYGZsq{}: 1, \PYGZsq{}V\PYGZsq{}: 0.5, \PYGZsq{}E\PYGZsq{}: 0.5, \PYGZsq{}A\PYGZsq{}: 100, \PYGZsq{}W\PYGZsq{}: 0.1, \PYGZsq{}l\PYGZus{}reorg\PYGZsq{}: 0.005, \PYGZsq{}boson\PYGZus{}mass\PYGZsq{}: 1\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Instantiating Algorithm Object}
\label{\detokenize{user_guide/quickstart/quickstart:instantiating-algorithm-object}}
\sphinxAtStartPar
Next, we instantiate an algorithm object which likewise has a set of default settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default algorithm settings: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm}\PYG{o}{.}\PYG{n}{default\PYGZus{}settings}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} default algorithm settings:  \PYGZob{}\PYGZcb{}}
\end{sphinxVerbatim}


\subsubsection{Setting Initial State}
\label{\detokenize{user_guide/quickstart/quickstart:setting-initial-state}}
\sphinxAtStartPar
Before using the dynamics driver to run the simulation, it is necessary to provide the simulation with an initial state. This initial state is
dependent on both the model and algorithm. For mean\sphinxhyphen{}field dynamics, we require a diabatic wavefunction called “wf\_db”. Because we are using a spin\sphinxhyphen{}boson model,
this wavefunction should have dimension 2. The initial state is stored in \sphinxtitleref{sim.state} which can be accessed as follows.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Running the Simulation}
\label{\detokenize{user_guide/quickstart/quickstart:running-the-simulation}}
\sphinxAtStartPar
Finally, we run the simulation using the dynamics driver. Here, we are using the serial driver. QC Lab comes with several different types of parallel drivers which are discussed elsewhere.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Analyzing Results}
\label{\detokenize{user_guide/quickstart/quickstart:analyzing-results}}
\sphinxAtStartPar
The data object returned by the dynamics driver contains the results of the simulation in a dictionary with keys corresponding
to the names of the observables that were requested to be recorded during the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calculated quantities:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} calculated quantities: dict\PYGZus{}keys([\PYGZsq{}seed\PYGZsq{}, \PYGZsq{}dm\PYGZus{}db\PYGZsq{}, \PYGZsq{}classical\PYGZus{}energy\PYGZsq{}, \PYGZsq{}quantum\PYGZus{}energy\PYGZsq{}])}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each of the calculated quantities is normalized with respect to the number of trajectories (note that this might depend on the type of algorithm used) and can be accessed through the \sphinxtitleref{data.data\_dict} attribute.
The normlaization factor for the data is kept in \sphinxtitleref{data.data\_dict{[}“norm\_factor”{]}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{norm\PYGZus{}factor} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{norm\PYGZus{}factor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{classical\PYGZus{}energy} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{classical\PYGZus{}energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{quantum\PYGZus{}energy} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quantum\PYGZus{}energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{populations} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{einsum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tii\PYGZhy{}\PYGZgt{}ti}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dm\PYGZus{}db}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The time axis can be retrieved from the simulation object through its settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{time} \PYG{o}{=} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{tdat\PYGZus{}output}
\end{sphinxVerbatim}


\subsubsection{Plotting Results}
\label{\detokenize{user_guide/quickstart/quickstart:plotting-results}}
\sphinxAtStartPar
Finally, we can plot the results of the simulation like the population dynamics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{populations}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{upper state}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{populations}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lower state}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{population}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{quickstart_populations}.png}\hspace*{\fill}}

\sphinxAtStartPar
We can verify that the total energy of the simulation was conserved by inspecting the change in energy of quantum and classical subsystems over time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{classical\PYGZus{}energy} \PYG{o}{\PYGZhy{}} \PYG{n}{classical\PYGZus{}energy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{classical energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{quantum\PYGZus{}energy} \PYG{o}{\PYGZhy{}} \PYG{n}{quantum\PYGZus{}energy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quantum energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{classical\PYGZus{}energy} \PYG{o}{+} \PYG{n}{quantum\PYGZus{}energy} \PYG{o}{\PYGZhy{}} \PYG{n}{classical\PYGZus{}energy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{quantum\PYGZus{}energy}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{total energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{quickstart_energies}.png}\hspace*{\fill}}


\subsubsection{Changing the Algorithm}
\label{\detokenize{user_guide/quickstart/quickstart:changing-the-algorithm}}
\sphinxAtStartPar
If you want to do a surface hopping calculation rather than a mean\sphinxhyphen{}field one, QC Lab makes it very easy to do so.
Simply import the relevant Algorithm class and set \sphinxtitleref{sim.algorithm} to it and rerun the calculation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{FewestSwitchesSurfaceHopping}

\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{FewestSwitchesSurfaceHopping}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The populations can be visualized in a similar way as before. Note that the simulation settings chosen here are solely for testing
purposes. Publication quality simulations would require checking convergence of the number of trajectories and the timestep.

\noindent{\hspace*{\fill}\sphinxincludegraphics{{quickstart_populations_fssh}.png}\hspace*{\fill}}

\noindent{\hspace*{\fill}\sphinxincludegraphics{{quickstart_energies_fssh}.png}\hspace*{\fill}}


\subsubsection{Changing the Driver}
\label{\detokenize{user_guide/quickstart/quickstart:changing-the-driver}}
\sphinxAtStartPar
You can likewise run the simulation using a parallel driver. Here we use the multiprocessing driver to split the trajectories
over four tasks.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}

\PYG{n}{data} \PYG{o}{=} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Units in QC Lab}
\label{\detokenize{user_guide/quickstart/quickstart:units-in-qc-lab}}
\sphinxAtStartPar
QC Lab is written assuming all energies are in units of the thermal quantum (\(k_{\mathrm{B}}T\)). Units of time are then determined by assuming a value for
the temperature defining the thermal quantum and calculating the equivalent timescales. For example, if we assume a standard temperature of \(T = 298.15\,\mathrm{K}\)
then the thermal quantum is \(k_{\mathrm{B}}T = 25.7\,\mathrm{meV}\) and one unit of time is \(\hbar/k_{\mathrm{B}}T = 25.6\,\mathrm{fs}\).

\sphinxstepscope


\subsection{Dynamics Drivers}
\label{\detokenize{user_guide/drivers/drivers:dynamics-drivers}}\label{\detokenize{user_guide/drivers/drivers:drivers}}\label{\detokenize{user_guide/drivers/drivers::doc}}
\sphinxAtStartPar
Drivers in QC Lab are functions that interface a Simulation object with the Dynamics core. Drivers are responsible for initializing the
objects needed for the Dynamics core to operate and handle the assignment of random seeds and the grouping of simulations into batches.

\sphinxstepscope


\subsubsection{Serial Driver}
\label{\detokenize{user_guide/drivers/serial_driver:serial-driver}}\label{\detokenize{user_guide/drivers/serial_driver:id1}}\label{\detokenize{user_guide/drivers/serial_driver::doc}}
\sphinxAtStartPar
The \sphinxtitleref{serial\_driver} function in the \sphinxtitleref{qc\_lab.dynamics} module is used to run simulations in serial.


\paragraph{Function Signature}
\label{\detokenize{user_guide/drivers/serial_driver:function-signature}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc\PYGZus{}lab}\PYG{o}{.}\PYG{n}{dynamics}\PYG{o}{.}\PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{seeds}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Parameters}
\label{\detokenize{user_guide/drivers/serial_driver:parameters}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sim} (\sphinxstyleemphasis{Simulation}): The simulation object that contains the model, settings, and state.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{seeds} (\sphinxstyleemphasis{array\sphinxhyphen{}like, optional}): An array of seed values for the random number generator. If not provided, seeds will be generated automatically.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{Data, optional}): A Data object to store the results of the simulation. If not provided, a new Data object will be created.

\end{itemize}


\paragraph{Returns}
\label{\detokenize{user_guide/drivers/serial_driver:returns}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{Data}): A Data object containing the results of the simulation.

\end{itemize}


\paragraph{Example}
\label{\detokenize{user_guide/drivers/serial_driver:example}}
\sphinxAtStartPar
Here is an example of how to use the \sphinxtitleref{serial\_driver} function to run a simulation assuming
that the simulation object has been set up according to the quickstart guide.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the serial driver}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver}

\PYG{c+c1}{\PYGZsh{} Run the simulation using the parallel driver}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{Parallel Multiprocessing Driver}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:parallel-multiprocessing-driver}}\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:parallel-driver-multiprocessing}}\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing::doc}}
\sphinxAtStartPar
The \sphinxtitleref{parallel\_driver\_multiprocessing} function in the \sphinxtitleref{qc\_lab.dynamics} module is used to run simulations in parallel
using the \sphinxtitleref{multiprocessing} library in Python. This driver is compatible with Jupyter notebooks and is useful for
calculations on a single node.


\paragraph{Function Signature}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:function-signature}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc\PYGZus{}lab}\PYG{o}{.}\PYG{n}{dynamics}\PYG{o}{.}\PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{seeds}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Parameters}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:parameters}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sim} (\sphinxstyleemphasis{Simulation}): The simulation object that contains the model, settings, and state.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{seeds} (\sphinxstyleemphasis{array\sphinxhyphen{}like, optional}): An array of seed values for the random number generator. If not provided, seeds will be generated automatically.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{Data, optional}): A Data object to store the results of the simulation. If not provided, a new Data object will be created.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{num\_tasks} (\sphinxstyleemphasis{int, optional}): The number of parallel tasks (processes) to use for the simulation. If not provided, the number of available CPU cores will be used.

\end{itemize}


\paragraph{Returns}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:returns}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{Data}): A Data object containing the results of the simulation.

\end{itemize}


\paragraph{Example}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:example}}
\sphinxAtStartPar
Here is an example of how to use the \sphinxtitleref{parallel\_driver\_multiprocessing} function to run a simulation in parallel assuming
that the simulation object has been set up according to the quickstart guide.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the parallel driver}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}

\PYG{c+c1}{\PYGZsh{} Run the simulation using the parallel driver}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Notes}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:notes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
This driver is suitable for use in Jupyter notebooks and single\sphinxhyphen{}node calculations.

\item {} 
\sphinxAtStartPar
For cluster\sphinxhyphen{}based calculations, consider using the MPI driver.

\end{itemize}


\paragraph{References}
\label{\detokenize{user_guide/drivers/parallel_driver_multiprocessing:references}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.python.org/3/library/multiprocessing.html}{multiprocessing library}

\end{itemize}

\sphinxstepscope


\subsubsection{MPI Driver}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:mpi-driver}}\label{\detokenize{user_guide/drivers/parallel_driver_mpi:parallel-driver-mpi}}\label{\detokenize{user_guide/drivers/parallel_driver_mpi::doc}}
\sphinxAtStartPar
The \sphinxtitleref{parallel\_driver\_mpi} function in the \sphinxtitleref{qc\_lab.dynamics} module is used to run simulations
in parallel using the \sphinxtitleref{mpi4py} library. This driver is suitable for use in cluster environments
and is compatible with different schedulers like SLURM. Unlike the multiprocessing driver, the MPI driver
requires a script to be run using the \sphinxtitleref{mpiexec} or \sphinxtitleref{mpirun} command.


\paragraph{Function Signature}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:function-signature}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{qc\PYGZus{}lab}\PYG{o}{.}\PYG{n}{dynamics}\PYG{o}{.}\PYG{n}{parallel\PYGZus{}driver\PYGZus{}mpi}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{seeds}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{data}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Parameters}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:parameters}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sim} (\sphinxstyleemphasis{Simulation}): The simulation object that contains the model, settings, and state.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{seeds} (\sphinxstyleemphasis{array\sphinxhyphen{}like, optional}): An array of seed values for the random number generator. If not provided, seeds will be generated automatically.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{Data, optional}): A Data object to store the results of the simulation. If not provided, a new Data object will be created.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{num\_tasks} (\sphinxstyleemphasis{int, optional}): The number of parallel tasks (processes) to use for the simulation. If not provided, the number of available MPI processes will be used.

\end{itemize}


\paragraph{Returns}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:returns}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{data} (\sphinxstyleemphasis{Data}): A Data object containing the results of the simulation.

\end{itemize}


\paragraph{Example}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:example}}
\sphinxAtStartPar
Here is an example of how to use the \sphinxtitleref{parallel\_driver\_mpi} function to run a simulation in parallel. Suppose the
following code is saved in a script called {\color{red}\bfseries{}\textasciigrave{}}mpi\_example.py\textasciigrave{}and that the simulation object has been set up
according to the quickstart guide.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Import the parallel driver}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}mpi}
\PYG{c+c1}{\PYGZsh{} Import the MPI module}
\PYG{k+kn}{from} \PYG{n+nn}{mpi4py} \PYG{k+kn}{import} \PYG{n}{MPI}

\PYG{c+c1}{\PYGZsh{} Initialize the sim object using the quickstart guide}

\PYG{c+c1}{\PYGZsh{} Run the simulation using the parallel driver}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}mpi}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Determine the rank of the current process}
\PYG{n}{rank} \PYG{o}{=} \PYG{n}{MPI}\PYG{o}{.}\PYG{n}{COMM\PYGZus{}WORLD}\PYG{o}{.}\PYG{n}{Get\PYGZus{}rank}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{rank} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} do something with the data only on the master process}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The parallel execution can be started using the \sphinxtitleref{mpiexec} or \sphinxtitleref{mpirun} command where the number of tasks
used in the execution should be the same as the one used in the call to \sphinxtitleref{parallel\_driver\_mpi}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mpirun\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{100}\PYG{+w}{ }python\PYG{+w}{ }parallel\PYGZus{}example.py
\end{sphinxVerbatim}

\sphinxAtStartPar
If using a scheduler like SLURM, the number of tasks can be specified in the job script. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}A \PYGZsh{} your allocation}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}p \PYGZsh{} your partition}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}N 2}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}ntasks\PYGZhy{}per\PYGZhy{}node 50}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}cpus\PYGZhy{}per\PYGZhy{}task 1}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}t 01:00:00}
\PYG{c+c1}{\PYGZsh{}SBATCH \PYGZhy{}\PYGZhy{}mem\PYGZhy{}per\PYGZhy{}cpu=1G}

\PYG{n+nb}{ulimit}\PYG{+w}{ }\PYGZhy{}c\PYG{+w}{ }\PYG{l+m}{0}
\PYG{n+nb}{ulimit}\PYG{+w}{ }\PYGZhy{}s\PYG{+w}{ }unlimited

mpirun\PYG{+w}{ }\PYGZhy{}n\PYG{+w}{ }\PYG{l+m}{100}\PYG{+w}{ }python\PYG{+w}{ }mpi\PYGZus{}example.py
\end{sphinxVerbatim}


\paragraph{Notes}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:notes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
This driver is suitable for use in cluster environments and is compatible with different schedulers like SLURM.

\item {} 
\sphinxAtStartPar
For single\sphinxhyphen{}node calculations, optionally consider using the multiprocessing driver.

\end{itemize}


\paragraph{References}
\label{\detokenize{user_guide/drivers/parallel_driver_mpi:references}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://mpi4py.readthedocs.io/en/stable/}{mpi4py library}

\end{itemize}

\sphinxstepscope


\subsection{Models}
\label{\detokenize{user_guide/models/models:models}}\label{\detokenize{user_guide/models/models:id1}}\label{\detokenize{user_guide/models/models::doc}}
\sphinxAtStartPar
Models in QC Lab are classes that define the physical properties of the system, minimally through the quantum, classical, and quantum\sphinxhyphen{}classical
Hamiltonians. Each model in QC Lab
has a set of constants that can be accessed by the user when the model is instantiated.

\sphinxstepscope


\subsubsection{Spin\sphinxhyphen{}Boson Model}
\label{\detokenize{user_guide/models/spin_boson_model:spin-boson-model}}\label{\detokenize{user_guide/models/spin_boson_model:id1}}\label{\detokenize{user_guide/models/spin_boson_model::doc}}
\sphinxAtStartPar
We employ the same Hamiltonian and naming conventions as in \sphinxhref{https://doi.org/10.1063/1.5000843}{Tempelaar \& Reichman 2019}.

\sphinxAtStartPar
The quantum\sphinxhyphen{}classical Hamiltonian of the spin\sphinxhyphen{}boson model is:
\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q}} = \left(\begin{array}{cc} E & V \\ V & -E \end{array}\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q-c}} = \sigma_{z} \sum_{\alpha}^{A}  g_{\alpha}q_{\alpha}\end{split}
\end{equation*}\begin{equation*}
\begin{split}H_{\mathrm{c}} = \sum_{\alpha}^{A} \frac{p_{\alpha}^{2}}{2m} + \frac{1}{2}m\omega_{\alpha}^{2}q_{\alpha}^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\sigma_{z}\) is the Pauli matrix, \(E\) is the diagonal energy, \(V\) is the off\sphinxhyphen{}diagonal coupling, and \(A\) is the number of bosons.

\sphinxAtStartPar
The couplings and frequencies are sampled from a Debye spectral density:
\begin{equation*}
\begin{split}\omega_{\alpha} = \Omega\tan\left(\frac{\alpha - 1/2}{2A}\pi\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}g_{\alpha} = \omega_{\alpha}\sqrt{\frac{2\lambda}{A}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Omega\) is the characteristic frequency and \(\lambda\) is the reorganization energy.

\sphinxAtStartPar
The classical coordinates are sampled from a Boltzmann distribution.
\begin{equation*}
\begin{split}P(\boldsymbol{p},\boldsymbol{q}) \propto \exp\left(-\frac{H_{\mathrm{c}}(\boldsymbol{p},\boldsymbol{q})}{k_{\mathrm{B}}T}\right)\end{split}
\end{equation*}

\paragraph{Constants}
\label{\detokenize{user_guide/models/spin_boson_model:constants}}
\sphinxAtStartPar
The following table lists all of the constants required by the \sphinxtitleref{SpinBosonModel} class:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{SpinBosonModel constants}\label{\detokenize{user_guide/models/spin_boson_model:id2}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameter (symbol)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default Value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{kBT} \((kBT)\)
&
\sphinxAtStartPar
Thermal quantum
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{V} \((V)\)
&
\sphinxAtStartPar
Off\sphinxhyphen{}diagonal coupling
&
\sphinxAtStartPar
0.5
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{E} \((E)\)
&
\sphinxAtStartPar
Diagonal energy
&
\sphinxAtStartPar
0.5
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{A} \((A)\)
&
\sphinxAtStartPar
Number of bosons
&
\sphinxAtStartPar
100
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{W} \((\Omega)\)
&
\sphinxAtStartPar
Characteristic frequency
&
\sphinxAtStartPar
0.1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{l\_reorg} \((\lambda)\)
&
\sphinxAtStartPar
Reorganization energy
&
\sphinxAtStartPar
0.005
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{boson\_mass} \((m)\)
&
\sphinxAtStartPar
Mass of the bosons
&
\sphinxAtStartPar
1
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Example}
\label{\detokenize{user_guide/models/spin_boson_model:example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{SpinBoson}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{MeanField}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} instantiate a simulation}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} instantiate a model}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{SpinBoson}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} instantiate an algorithm}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define an initial diabatic wavefunction}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{Holstein Lattice Model}
\label{\detokenize{user_guide/models/holstein_model:holstein-lattice-model}}\label{\detokenize{user_guide/models/holstein_model:holstein-model}}\label{\detokenize{user_guide/models/holstein_model::doc}}
\sphinxAtStartPar
The Holstein Lattice Model is a nearest\sphinxhyphen{}neighbor tight\sphinxhyphen{}binding model combined with an idealized optical phonon that interacts via a
Holstein coupling. The current implementation accommodates a single electronic particle and is described in detail in \sphinxhref{https://doi.org/10.1063/5.0053177}{Krotz et al. 2021}
.

\sphinxAtStartPar
The quantum Hamiltonian of the Holstein model is a nearest\sphinxhyphen{}neighbor tight\sphinxhyphen{}binding model
\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q}} = -J\sum_{\langle i,j\rangle}^{N}\hat{c}^{\dagger}_{i}\hat{c}_{j}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\langle i,j\rangle\) denotes nearest\sphinxhyphen{}neighbor sites with or without periodic boundaries determined by the parameter \sphinxtitleref{periodic\_boundary=True}.

\sphinxAtStartPar
The quantum\sphinxhyphen{}classical Hamiltonian is the Holstein coupling with dimensionless electron\sphinxhyphen{}phonon coupling \(g\) and phonon frequency \(\omega\)
\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q-c}} = g\sqrt{2m\omega^{3}}\sum_{i}^{N} \hat{c}^{\dagger}_{i}\hat{c}_{i} q_{i}\end{split}
\end{equation*}
\sphinxAtStartPar
and the classical Hamiltonian is the harmonic oscillator
\begin{equation*}
\begin{split}H_{\mathrm{c}} = \sum_{i}^{N} \frac{p_{i}^{2}}{2m} + \frac{1}{2}m\omega^{2}q_{i}^{2}\end{split}
\end{equation*}
\sphinxAtStartPar
with mass \(m\).

\sphinxAtStartPar
The classical coordinates are sampled from a Boltzmann distribution.
\begin{equation*}
\begin{split}P(\boldsymbol{p},\boldsymbol{q}) \propto \exp\left(-\frac{H_{\mathrm{c}}(\boldsymbol{p},\boldsymbol{q})}{k_{\mathrm{B}}T}\right)\end{split}
\end{equation*}

\paragraph{Constants}
\label{\detokenize{user_guide/models/holstein_model:constants}}
\sphinxAtStartPar
The following table lists all of the constants required by the \sphinxtitleref{HolsteinLatticeModel} class:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{HolsteinLatticeModel constants}\label{\detokenize{user_guide/models/holstein_model:id1}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameter (symbol)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default Value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{temp} \((T)\)
&
\sphinxAtStartPar
Temperature
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{g} \((g)\)
&
\sphinxAtStartPar
Dimensionless electron\sphinxhyphen{}phonon coupling
&
\sphinxAtStartPar
0.5
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{w} \((\omega)\)
&
\sphinxAtStartPar
Phonon frequency
&
\sphinxAtStartPar
0.5
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{N} \((N)\)
&
\sphinxAtStartPar
Number of sites
&
\sphinxAtStartPar
10
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{J} \((J)\)
&
\sphinxAtStartPar
Hopping energy
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{phonon\_mass} \((m)\)
&
\sphinxAtStartPar
Phonon mass
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{periodic\_boundary}
&
\sphinxAtStartPar
Periodic boundary condition
&
\sphinxAtStartPar
\sphinxtitleref{True\textasciigrave{}}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Example}
\label{\detokenize{user_guide/models/holstein_model:example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{HolsteinLattice}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{MeanField}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} instantiate a simulation}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} instantiate a model}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{HolsteinLattice}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} instantiate an algorithm}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define an initial diabatic wavefunction}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}quantum\PYGZus{}states}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{Fenna\sphinxhyphen{}Matthews\sphinxhyphen{}Olson Model}
\label{\detokenize{user_guide/models/fmo_model:fenna-matthews-olson-model}}\label{\detokenize{user_guide/models/fmo_model:fmo-model}}\label{\detokenize{user_guide/models/fmo_model::doc}}
\sphinxAtStartPar
The Fenna\sphinxhyphen{}Matthews\sphinxhyphen{}Olson (FMO) complex is a pigment\sphinxhyphen{}protein complex found in green sulfur bacteria. We implemented it in QC Lab as an
7 site model with Holstein\sphinxhyphen{}type coupling to local vibrational modes with couplings and frequencies sampled from a Debye spectral
density according to \sphinxhref{https://doi.org/10.1063/5.0051101}{Mulvihill et. al 2021}.
\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q}} = \begin{pmatrix}
    12410 & -87.7 & 5.5 & -5.9 & 6.7 & -13.7 & -9.9 \\
    -87.7 & 12530 & 30.8 & 8.2 & 0.7 & 11.8 & 4.3 \\
    5.5 & 30.8 & 12210.0 & -53.5 & -2.2 & -9.6 & 6.0 \\
    -5.9 & 8.2 & -53.5 & 12320 & -70.7 & -17.0 & -63.3 \\
    6.7 & 0.7 & -2.2 & -70.7 & 12480 & 81.1 & -1.3 \\
    -13.7 & 11.8 & -9.6 & -17.0 & 81.1 & 12630 & 39.7 \\
    -9.9 & 4.3 & 6.0 & -63.3 & -1.3 & 39.7 & 12440
\end{pmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
where the matrix elements above are in units of wavenumbers. Note that the values below are in units of thermal quantum at 298.15K.

\sphinxAtStartPar
The quantum\sphinxhyphen{}classical and classical Hamiltonians are
\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q-c}} = \sum_{i}\sum_{j}^{A}\omega_{j}g_{j}c^{\dagger}_{i}c_{i}q_{j}^{(i)}\end{split}
\end{equation*}\begin{equation*}
\begin{split}H_{\mathrm{c}} = \sum_{i}\sum_{j}^{A} \frac{p_{j}^{(i)2}}{2m} + \frac{1}{2}m\omega_{j}^{2}q_{j}^{(i)2}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(q^{(i)}_{j}\) is the \(j\)\sphinxhyphen{}th coordinate coupled to site \(i\) and \(p^{(i)}_{j}\) is the corresponding momentum.

\sphinxAtStartPar
The couplings and frequencies are sampled from a Debye spectral density
\begin{equation*}
\begin{split}\omega_{j} = \Omega\tan\left(\frac{j - 1/2}{2A}\pi\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}g_{j} = \omega_{j}\sqrt{\frac{2\lambda}{A}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Omega\) is the characteristic frequency and \(\lambda\) is the reorganization energy.

\sphinxAtStartPar
The classical coordinates are sampled from a Boltzmann distribution.
\begin{equation*}
\begin{split}P(\boldsymbol{p},\boldsymbol{q}) \propto \exp\left(-\frac{H_{\mathrm{c}}(\boldsymbol{p},\boldsymbol{q})}{k_{\mathrm{B}}T}\right)\end{split}
\end{equation*}

\paragraph{Constants}
\label{\detokenize{user_guide/models/fmo_model:constants}}
\sphinxAtStartPar
The following table lists all of the constants required by the \sphinxtitleref{HolsteinLatticeModel} class:


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{HolsteinLatticeModel constants}\label{\detokenize{user_guide/models/fmo_model:id1}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Parameter (symbol)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default Value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{temp} \((T)\)
&
\sphinxAtStartPar
Temperature
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{mass} \((m)\)
&
\sphinxAtStartPar
Vibrational mass
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{A} \((A)\)
&
\sphinxAtStartPar
Number of bosons
&
\sphinxAtStartPar
200
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{W} \((\Omega)\)
&
\sphinxAtStartPar
Characteristic frequency
&
\sphinxAtStartPar
106.14 \(\mathrm{cm}^{-1}\)
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{l\_reorg} \((\lambda)\)
&
\sphinxAtStartPar
Reorganization energy
&
\sphinxAtStartPar
35 \(\mathrm{cm}^{-1}\)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Example}
\label{\detokenize{user_guide/models/fmo_model:example}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{FMOComplex}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{MeanField}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} instantiate a simulation}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} instantiate a model}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{FMOComplex}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} instantiate an algorithm}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} define an initial diabatic wavefunction}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}quantum\PYGZus{}states}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsection{Algorithms}
\label{\detokenize{user_guide/algorithms/algorithms:algorithms}}\label{\detokenize{user_guide/algorithms/algorithms:id1}}\label{\detokenize{user_guide/algorithms/algorithms::doc}}
\sphinxAtStartPar
Algorithms in QC Lab are classes that can be paired with models to carry out quantum\sphinxhyphen{}classical dynamics simulations.
Like models, each algorithm in QC Lab has a set of settings that allow users to control particular aspects of the
algorithm.

\sphinxstepscope


\subsubsection{Mean\sphinxhyphen{}Field Dynamics}
\label{\detokenize{user_guide/algorithms/mf_algorithm:mean-field-dynamics}}\label{\detokenize{user_guide/algorithms/mf_algorithm:mf-algorithm}}\label{\detokenize{user_guide/algorithms/mf_algorithm::doc}}
\sphinxAtStartPar
The \sphinxtitleref{qc\_lab.algorithms.MeanField} class implements the mean\sphinxhyphen{}field (Ehrenfest) dynamics algorithm according to \sphinxhref{https://doi.org/10.1039/A801824C}{Tully 1998}.


\paragraph{Settings}
\label{\detokenize{user_guide/algorithms/mf_algorithm:settings}}
\sphinxAtStartPar
The mean\sphinxhyphen{}field algorithm has no default settings.


\paragraph{Initial State}
\label{\detokenize{user_guide/algorithms/mf_algorithm:initial-state}}
\sphinxAtStartPar
The mean\sphinxhyphen{}field algorithm requires an initial diabatic wavefunction called \sphinxtitleref{wf\_db} which is a complex NumPy array with dimension \sphinxtitleref{sim.model.constants.num\_quantum\_states}.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Output Variables}
\label{\detokenize{user_guide/algorithms/mf_algorithm:output-variables}}
\sphinxAtStartPar
The following table lists the default output variables for the \sphinxtitleref{MeanField} class.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{\sphinxtitleref{MeanField} Output Variables}\label{\detokenize{user_guide/algorithms/mf_algorithm:id1}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{classical\_energy}
&
\sphinxAtStartPar
Energy in the classical subsystem
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{quantum\_energy}
&
\sphinxAtStartPar
Energy in the quantum subsystem
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{dm\_db}
&
\sphinxAtStartPar
Diabatic density matrix
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Example}
\label{\detokenize{user_guide/algorithms/mf_algorithm:example}}
\sphinxAtStartPar
The following example demonstrates how to run a mean\sphinxhyphen{}field simulation for a spin\sphinxhyphen{}boson model using all default settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation} \PYG{c+c1}{\PYGZsh{} import simulation class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{SpinBoson} \PYG{c+c1}{\PYGZsh{} import model class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{MeanField} \PYG{c+c1}{\PYGZsh{} import algorithm class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver} \PYG{c+c1}{\PYGZsh{} import dynamics driver}

\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{SpinBoson}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsubsection{Fewest\sphinxhyphen{}Switches Surface Hopping}
\label{\detokenize{user_guide/algorithms/fssh_algorithm:fewest-switches-surface-hopping}}\label{\detokenize{user_guide/algorithms/fssh_algorithm:fssh-algorithm}}\label{\detokenize{user_guide/algorithms/fssh_algorithm::doc}}
\sphinxAtStartPar
The \sphinxtitleref{qc\_lab.algorithms.FewestSwitchesSurfaceHopping} class implements Tully’s Fewest\sphinxhyphen{}Switches Surface Hopping (FSSH) dynamics algorithm according to \sphinxhref{https://doi.org/10.1063/1.467455}{Hammes\sphinxhyphen{}Schiffer 1994}.


\paragraph{Settings}
\label{\detokenize{user_guide/algorithms/fssh_algorithm:settings}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{\sphinxtitleref{FewestSwitchesSurfaceHopping} settings}\label{\detokenize{user_guide/algorithms/fssh_algorithm:id1}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{30}{130}\X{80}{130}\X{20}{130}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Setting name (type)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{fssh\_deterministic (bool)}
&
\sphinxAtStartPar
If \sphinxtitleref{True} the algorithm uses a deterministic representation of the initial state by propagating all possible initial active surfaces. If \sphinxtitleref{False}, it samples the initial active surface according to the adiabatic populations.
&
\sphinxAtStartPar
\sphinxtitleref{False}
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{gauge\_fixing (int=0,1,2)}
&
\sphinxAtStartPar
The level of gauge fixing to employ on the eigenvectors at each timestep. (0: adjust only the sign, 1: adjust the sign and phase using the overlap with the previous timestep, 2: adjust the sign and phase by calculating the derivative couplings.)
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Initial State}
\label{\detokenize{user_guide/algorithms/fssh_algorithm:initial-state}}
\sphinxAtStartPar
The FSSH algorithm requires an initial diabatic wavefunction called \sphinxtitleref{wf\_db} which is a complex NumPy array with dimension \sphinxtitleref{sim.model.constants.num\_quantum\_states}.
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Output Variables}
\label{\detokenize{user_guide/algorithms/fssh_algorithm:output-variables}}
\sphinxAtStartPar
The following table lists the default output variables for the \sphinxtitleref{FewestSwitchesSurfaceHopping} class.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{\sphinxtitleref{FewestSwitchesSurfaceHopping} Output Variables}\label{\detokenize{user_guide/algorithms/fssh_algorithm:id2}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{classical\_energy}
&
\sphinxAtStartPar
Energy in the classical subsystem
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{quantum\_energy}
&
\sphinxAtStartPar
Energy in the quantum subsystem
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{dm\_db}
&
\sphinxAtStartPar
Diabatic density matrix
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Example}
\label{\detokenize{user_guide/algorithms/fssh_algorithm:example}}
\sphinxAtStartPar
The following example demonstrates how to run a mean\sphinxhyphen{}field simulation for a spin\sphinxhyphen{}boson model using all default settings.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation} \PYG{c+c1}{\PYGZsh{} import simulation class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{SpinBoson} \PYG{c+c1}{\PYGZsh{} import model class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{FewestSwitchesSurfaceHopping} \PYG{c+c1}{\PYGZsh{} import algorithm class}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver} \PYG{c+c1}{\PYGZsh{} import dynamics driver}

\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{SpinBoson}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{FewestSwitchesSurfaceHopping}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\subsection{Data Object}
\label{\detokenize{user_guide/data_object:data-object}}\label{\detokenize{user_guide/data_object:id1}}\label{\detokenize{user_guide/data_object::doc}}
\sphinxAtStartPar
The Data object in QC Lab is used to store the results of simulations. Data objects come with a variety of methods that are intended as
quality\sphinxhyphen{}of\sphinxhyphen{}life features to make using QC Lab easier. Here we review those methods.

\sphinxAtStartPar
Assuming we have a data object or have initialized one as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{Data}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Methods}
\label{\detokenize{user_guide/data_object:methods}}\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!data.add\_data()@\spxentry{data.add\_data()}}\index{data.add\_data()@\spxentry{data.add\_data()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/data_object:data.add_data}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{data.}}\sphinxbfcode{\sphinxupquote{add\_data}}}
{\sphinxparam{\DUrole{n}{new\_data}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Adds the data from new\_data to the data object. Joins the seeds together and sums any
data with the same keys.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{new\_data}} \textendash{} An input data object.

\end{description}\end{quote}

\end{fulllineitems}

\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!data.save\_as\_h5()@\spxentry{data.save\_as\_h5()}}\index{data.save\_as\_h5()@\spxentry{data.save\_as\_h5()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/data_object:data.save_as_h5}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{data.}}\sphinxbfcode{\sphinxupquote{save\_as\_h5}}}
{\sphinxparam{\DUrole{n}{filename}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Saves the data in the data object as an HDF5 file.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} A string providing the name of the file to save the data to.

\end{description}\end{quote}

\end{fulllineitems}

\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!data.load\_from\_h5()@\spxentry{data.load\_from\_h5()}}\index{data.load\_from\_h5()@\spxentry{data.load\_from\_h5()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/data_object:data.load_from_h5}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{data.}}\sphinxbfcode{\sphinxupquote{load\_from\_h5}}}
{\sphinxparam{\DUrole{n}{filename}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Loads data into the data object from an HDF5 file.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} A string providing the name of the file to load the data from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
The Data object with the loaded data.

\end{description}\end{quote}

\end{fulllineitems}



\subsubsection{Attributes}
\label{\detokenize{user_guide/data_object:attributes}}\index{data\_dic (data attribute)@\spxentry{data\_dic}\spxextra{data attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/data_object:data.data_dic}}
\pysigstartsignatures
\pysigline
{\sphinxcode{\sphinxupquote{data.}}\sphinxbfcode{\sphinxupquote{data\_dic}}}
\pysigstopsignatures
\sphinxAtStartPar
A dictionary containing the data stored in the Data object. By default, this contains the seeds
(\sphinxtitleref{data.data\_dict{[}“seed”{]}})
used in the simulation. In a new data object, this list is empty.

\end{fulllineitems}


\sphinxstepscope


\subsection{Model Development}
\label{\detokenize{user_guide/model_dev:model-development}}\label{\detokenize{user_guide/model_dev::doc}}
\sphinxAtStartPar
This page will guide you in the construction of a new Model Class for use in QC Lab.

\sphinxAtStartPar
The model class describes a physical model as a set of functions referred to as “ingredients”.
QC Lab is designed to accommodate a minimal model that consists of only a quantum\sphinxhyphen{}classical Hamiltonian.
However, by incorporating additional ingredients, such as analytic gradients, the performance of QC Lab can be greatly improved.
We will first describe the construction of a minimal model class, and then discuss how to incorporate additional ingredients.

\begin{sphinxcontents}
\sphinxstylecontentstitle{Table of Contents}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id1}}{\hyperref[\detokenize{user_guide/model_dev:minimal-model-class}]{\sphinxcrossref{Minimal Model Class}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id2}}{\hyperref[\detokenize{user_guide/model_dev:initialization-functions}]{\sphinxcrossref{Initialization functions}}}

\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id3}}{\hyperref[\detokenize{user_guide/model_dev:ingredients}]{\sphinxcrossref{Ingredients}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id4}}{\hyperref[\detokenize{user_guide/model_dev:upgrading-the-model-class}]{\sphinxcrossref{Upgrading the Model Class}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id5}}{\hyperref[\detokenize{user_guide/model_dev:vectorized-ingredients}]{\sphinxcrossref{Vectorized Ingredients}}}

\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id6}}{\hyperref[\detokenize{user_guide/model_dev:analytic-gradients}]{\sphinxcrossref{Analytic Gradients}}}

\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id7}}{\hyperref[\detokenize{user_guide/model_dev:classical-initialization}]{\sphinxcrossref{Classical Initialization}}}

\item {} 
\sphinxAtStartPar
\phantomsection\label{\detokenize{user_guide/model_dev:id8}}{\hyperref[\detokenize{user_guide/model_dev:using-built-in-ingredients}]{\sphinxcrossref{Using Built\sphinxhyphen{}in Ingredients}}}

\end{itemize}

\end{itemize}
\end{sphinxcontents}


\subsubsection{Minimal Model Class}
\label{\detokenize{user_guide/model_dev:minimal-model-class}}
\sphinxAtStartPar
A physical model in QC Lab is assumed to consist of a Hamiltonian following the formalism developed in \sphinxhref{https://doi.org/10.1021/acs.jctc.4c00555}{Miyazaki 2024}
\begin{equation*}
\begin{split}\hat{H}(\boldsymbol{z}) = \hat{H}_{\mathrm{q}} + \hat{H}_{\mathrm{q-c}}(\boldsymbol{z}) + H_{\mathrm{c}}(\boldsymbol{z})\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\hat{H}_{\mathrm{q}}\) is the quantum Hamiltonian, \(\hat{H}_{\mathrm{q-c}}\) is the quantum\sphinxhyphen{}classical coupling Hamiltonian,
and \(H_{\mathrm{c}}\) is the classical Hamiltonian. \(\boldsymbol{z}\) is a complex\sphinxhyphen{}valued classical coordinate that defines the
classical degrees of freedom.

\sphinxAtStartPar
Before describing how the model ingredients should be structured in the model class, we will first describe the \sphinxtitleref{\_\_init\_\_} method of the model class
which is responsible for initializing the default model constants and any input constants into the set of constants needed for QC Lab and all
of the model ingredients to run.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Model}  \PYG{c+c1}{\PYGZsh{} import the model class}

\PYG{c+c1}{\PYGZsh{} create a minimal spin\PYGZhy{}boson model subclass}
\PYG{k}{class} \PYG{n+nc}{MinimalSpinBoson}\PYG{p}{(}\PYG{n}{Model}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{constants} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{constants} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants} \PYG{o}{=} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.1}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l\PYGZus{}reorg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.005}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boson\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
In the above example, the \sphinxtitleref{\_\_init\_\_} method takes an optional \sphinxtitleref{constants} dictionary which is added to the \sphinxtitleref{default\_constants} dictionary by
\sphinxtitleref{super().\_\_init\_\_}. The \sphinxtitleref{default\_constants} dictionary contains the default input constants for the model. These constants are independent from the
internal constants required by QC Lab to function and are instead drawn from the analytic formulation of the spin\sphinxhyphen{}boson model.
\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q}} = \left(\begin{array}{cc} E & V \\ V & -E \end{array}\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\hat{H}_{\mathrm{q-c}} = \sigma_{z} \sum_{\alpha}^{A}  \frac{g_{\alpha}}{\sqrt{2mh_{\alpha}}} \left(z^{*}_{\alpha} + z_{\alpha}\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}H_{\mathrm{c}} = \sum_{\alpha}^{A} \omega_{\alpha} z^{*}_{\alpha} z_{\alpha}\end{split}
\end{equation*}
\sphinxAtStartPar
Here \(\sigma_{z}\) is the Pauli\sphinxhyphen{}z matrix (\(\sigma_{z}=\vert0\rangle\langle 0\vert - \vert 1\rangle\langle 1\vert\)), \(g_{\alpha}\) is the coupling strength,
\(m\) is the boson mass, \(h_{\alpha}\) is the complex\sphinxhyphen{}valued coordinate weight (which here we may take to correspond to the frequencies: \(h_{\alpha}=\omega_{\alpha}\)),
and \(A\) is the number of bosons. We sample the frequencies and coupling strengths from a Debye spectral density which is discretized to obtain
\begin{equation*}
\begin{split}\omega_{\alpha} = \Omega\tan\left(\frac{\alpha - 1/2}{2A}\pi\right)\end{split}
\end{equation*}\begin{equation*}
\begin{split}g_{\alpha} = \omega_{\alpha}\sqrt{\frac{2\lambda}{A}}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\Omega\) is the characteristic frequency and \(\lambda\) is the reorganization energy.

\sphinxAtStartPar
In a spin\sphinxhyphen{}boson model, the number of bosons \(A\) can be quite large (e.g, 100). Rather than specifying every value of \(\omega_{\alpha}\)
and \(g_{\alpha}\) in the input constants, we can instead specify the characteristic frequency \(\Omega\) and the reorganization energy \(\lambda\).
We can then use an internal function to generate the remaining constants needed by the model and any constants needed by QC Lab.


\paragraph{Initialization functions}
\label{\detokenize{user_guide/model_dev:initialization-functions}}
\sphinxAtStartPar
This is accomplished by specifying a list of functions called \sphinxtitleref{initialization\_functions} as an attribute of the model class. These functions will
be executed by the Model superclass when the model is instantiated or whenever a constant is changed. Because it is a list of functions, it is executed
from start to finish, so the order of the functions can sometimes be important. The first function we will specify initializes the model constants and make
use of the \sphinxtitleref{get} method of the Constants object (\sphinxtitleref{self.constants}) to obtain the input constants. We use the \sphinxtitleref{get} method of the
\sphinxtitleref{default\_constants} dictionary (\sphinxtitleref{self.default\_constants}) to obtain the default constants in the event that the input constant has not been specified.

\sphinxAtStartPar
Here, we initialize the constants needed by QC Lab which are the number of classical coordinates (\sphinxtitleref{sim.model.constants.num\_classical\_coordinates}),
the number of quantum states (\sphinxtitleref{sim.model.constants.num\_quantum\_states}), the classical coordinate weight (\sphinxtitleref{sim.model.constants.classical\_coordinate\_weight}),
and the classical coordinate mass (\sphinxtitleref{sim.model.constants.classical\_coordinate\_mass}). Because the classical Hamiltonian is a harmonic oscillator,
we set the classical coordinate weight to the oscillator frequencies (\sphinxtitleref{sim.model.constant.w}) even though these frequencies are not strictly speaking a
constant needed by QC Lab (they would otherwise be specified in the initialization function for the classical Hamiltonian).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}model}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{char\PYGZus{}freq} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{boson\PYGZus{}mass} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w} \PYG{o}{=} \PYG{n}{char\PYGZus{}freq} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tan}\PYG{p}{(}
        \PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{num\PYGZus{}bosons}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} The following constants are required by QC Lab}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{num\PYGZus{}bosons}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}quantum\PYGZus{}states} \PYG{o}{=} \PYG{l+m+mi}{2}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass} \PYG{o}{=} \PYG{n}{boson\PYGZus{}mass} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we define a function which initializes the constants needed by the classical Hamiltonian, quantum Hamiltonian, and quantum\sphinxhyphen{}classical Hamiltonian. Be aware that the
constants we define in the functions are dictated by the requirements of the ingredients (these are defined in the {\hyperref[\detokenize{software_reference/ingredients/ingredients:ingredients}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{Ingredients}}}}} section).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the classical Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{w} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency} \PYG{o}{=} \PYG{n}{w}


\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the quantum\PYGZhy{}classical coupling Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{w} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{l\PYGZus{}reorg} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling} \PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{l\PYGZus{}reorg} \PYG{o}{/} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the quantum Hamiltonian. None are required in this case.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
These are all placed into the \sphinxtitleref{initialization\_functions} list in the model class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{initialization\PYGZus{}functions} \PYG{o}{=} \PYG{p}{[}
    \PYG{n}{initialize\PYGZus{}constants\PYGZus{}model}\PYG{p}{,}
    \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{,}
    \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{,}
    \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{,}
\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you can check that the updating of model constants is functioning properly by changing one of the input constants (\sphinxtitleref{A} for example) and then checking that
the coupling strengths are updated appropriately:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{MinimalSpinBoson}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{A} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coupling strengths: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} should be a list of length 10}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{A} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coupling strengths: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} should be a list of length 5}
\end{sphinxVerbatim}


\paragraph{Ingredients}
\label{\detokenize{user_guide/model_dev:ingredients}}
\sphinxAtStartPar
Now we can add the minimal set of ingredients to the model class. The ingredients are the quantum Hamiltonian,
the quantum\sphinxhyphen{}classical coupling Hamiltonian, and the classical Hamiltonian. The ingredients in a model class
take a standard form which is required by QC Lab.

\sphinxAtStartPar
A generic ingredients has as arguments the model class itself, the constants object containing time independent quantities (stored in \sphinxtitleref{sim.model.constants}), and
the parameters object which contain potentially time\sphinxhyphen{}dependent quantities (stored in \sphinxtitleref{sim.model.parameters}). The ingredients can also take additional keyword arguments
which are passed to the ingredient when it is called. The ingredients return the result of the calculation directly. Typically, users will never call ingredients as they
are internal functions used by QC Lab to define the model.

\sphinxAtStartPar
As an example we will use the quantum Hamiltonian. Importantly, QC Lab is a vectorized code capable of calculating multiple quantum\sphinxhyphen{}classical trajectories simultaneously.
As a result, the ingredients must also be vectorized, meaning that they accept as input quantities with an additional dimension corresponding to the number of trajectories
(this is taken to be the first dimension as a convention). The quantum Hamiltonian is a \(2\times 2\) matrix and so the vectorized quantum Hamiltonian is a 3D array with shape
\sphinxtitleref{(len(parameters.seed), 2, 2)} where the number of trajectories is given by the number of seeds in the parameters object.

\sphinxAtStartPar
Rather than writing a vectorized ingredient (which will be discussed later) we can invoke a decorator (\sphinxtitleref{ingredients.vectorize}) which will automatically vectorize the ingredient
at the cost of some performance (it is strongly recommended to write vectorized ingredients as a first pass for performance optimization).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{ingredients} \PYG{k}{as} \PYG{n+nn}{ingredients}

\PYG{n+nd}{@ingredients}\PYG{o}{.}\PYG{n}{vectorize\PYGZus{}ingredient}
\PYG{k}{def} \PYG{n+nf}{h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{E} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{E}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{V}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{E}\PYG{p}{,} \PYG{n}{V}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{V}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{E}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The rest of the model ingredients can likewise be written:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nd}{@ingredients}\PYG{o}{.}\PYG{n}{vectorize\PYGZus{}ingredient}
\PYG{k}{def} \PYG{n+nf}{h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
    \PYG{n}{h\PYGZus{}qc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{g} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{z} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{h\PYGZus{}qc}

\PYG{n+nd}{@ingredients}\PYG{o}{.}\PYG{n}{vectorize\PYGZus{}ingredient}
\PYG{k}{def} \PYG{n+nf}{h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}
    \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{*} \PYG{n}{z}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now you have a working model class which you can instantiate and use following the instructions in the Quick tart Guide!

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Please be aware that the performance is going to be significantly worse than what can be achieved by implementing the
upgrades below.
\end{sphinxadmonition}

\sphinxAtStartPar
Prior to implementing upgrades, a minimal model will be subject to a number of defaults which are discussed in the {\hyperref[\detokenize{user_guide/defaults:defaults}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{Default Behavior}}}}} section.

\sphinxAtStartPar
The full minimal model looks like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{MinimalSpinBoson}\PYG{p}{(}\PYG{n}{Model}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{constants} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{constants} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants} \PYG{o}{=} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.1}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l\PYGZus{}reorg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.005}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boson\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}model}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{char\PYGZus{}freq} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{boson\PYGZus{}mass} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w} \PYG{o}{=} \PYG{n}{char\PYGZus{}freq} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tan}\PYG{p}{(}
            \PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{num\PYGZus{}bosons}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} The following constants are required by QC Lab}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{num\PYGZus{}bosons}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}quantum\PYGZus{}states} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass} \PYG{o}{=} \PYG{n}{boson\PYGZus{}mass} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initialize the constants for the classical Hamiltonian.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{w} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency} \PYG{o}{=} \PYG{n}{w}


    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initialize the constants for the quantum\PYGZhy{}classical coupling Hamiltonian.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{w} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{l\PYGZus{}reorg} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling} \PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{l\PYGZus{}reorg} \PYG{o}{/} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initialize the constants for the quantum Hamiltonian. None are required in this case.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{initialization\PYGZus{}functions} \PYG{o}{=} \PYG{p}{[}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}model}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{,}
    \PYG{p}{]}

    \PYG{n+nd}{@ingredients}\PYG{o}{.}\PYG{n}{vectorize\PYGZus{}ingredient}
    \PYG{k}{def} \PYG{n+nf}{h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{E} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{E}
        \PYG{n}{V} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{V}
        \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{n}{E}\PYG{p}{,} \PYG{n}{V}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{V}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n}{E}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}

    \PYG{n+nd}{@ingredients}\PYG{o}{.}\PYG{n}{vectorize\PYGZus{}ingredient}
    \PYG{k}{def} \PYG{n+nf}{h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
        \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
        \PYG{n}{h\PYGZus{}qc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
        \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{n}{g} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{z} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{h\PYGZus{}qc}

    \PYG{n+nd}{@ingredients}\PYG{o}{.}\PYG{n}{vectorize\PYGZus{}ingredient}
    \PYG{k}{def} \PYG{n+nf}{h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}
        \PYG{k}{return} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{*} \PYG{n}{z}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Upgrading the Model Class}
\label{\detokenize{user_guide/model_dev:upgrading-the-model-class}}

\paragraph{Vectorized Ingredients}
\label{\detokenize{user_guide/model_dev:vectorized-ingredients}}
\sphinxAtStartPar
The first upgrade we recommend is to include vectorized ingredients. Vectorized ingredients are ingredients that can be computed for a batch of
trajectories simultaneously. If implemented making use of broadcasting and vectorized NumPy functions, vectorized ingredients can greatly improve
the performance of QC Lab.

\sphinxAtStartPar
Here we show vectorized versions of the ingredients used in the minimal model. Since they are vectorized, they do not need to use the \sphinxtitleref{@ingredients.vectorize\_ingredient}
decorator. An important feature of vectorized ingredients is how they determine the number of trajectories being calculated. In ingredients that depend on the classical coordinate
this is done by comparing the shape of the first index of the classical coordinate to the provided \sphinxtitleref{batch\_size} parameter. In others where the classical coordinate is not
provided, the \sphinxtitleref{batch\_size} is compared to the number of seeds in the simulation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{parameters}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{)}
    \PYG{n}{E} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{E}
    \PYG{n}{V} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{V}
    \PYG{n}{h\PYGZus{}q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{E}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{E}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{V}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{V}
    \PYG{k}{return} \PYG{n}{h\PYGZus{}q}


\PYG{k}{def} \PYG{n+nf}{h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
    \PYG{n}{g} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
    \PYG{n}{h\PYGZus{}qc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}
        \PYG{n}{g} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{z} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{p}{)}
    \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{return} \PYG{n}{h\PYGZus{}qc}

\PYG{k}{def} \PYG{n+nf}{h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}

    \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
    \PYG{n}{q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
    \PYG{n}{p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}c} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{m} \PYG{o}{*} \PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{h\PYGZus{}c}
\end{sphinxVerbatim}


\paragraph{Analytic Gradients}
\label{\detokenize{user_guide/model_dev:analytic-gradients}}
\sphinxAtStartPar
Derivatives of the Hamiltonian with respect to each classical coordinate (refered to here as gradients) are automatically calculated in QC Lab using a
finite difference method. This can cause significant computational overhead and can be avoided by providing ingredients
that return the gradients based on analytic formulas. The gradient of the classical Hamiltonian in the spin\sphinxhyphen{}boson model is given by
\begin{equation*}
\begin{split}\frac{\partial H_{\mathrm{c}}}{\partial z^{*}_{\alpha}} = \frac{1}{2}\left(\frac{\omega^{2}_{\alpha}}{h_{\alpha}} + h_{\alpha}\right)z_{\alpha} +
        \frac{1}{2}\left(\frac{\omega^{2}_{\alpha}}{h_{\alpha}} - h_{\alpha}\right)z^{*}_{\alpha}\end{split}
\end{equation*}
\sphinxAtStartPar
which can be implemented in a vectorized fashion as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dh\PYGZus{}c\PYGZus{}dzc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}
    \PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}
        \PYG{p}{(}\PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{h}
    \PYG{p}{)}
    \PYG{n}{b} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}
        \PYG{p}{(}\PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{n}{h}
    \PYG{p}{)}
    \PYG{n}{dh\PYGZus{}c\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{n}{z} \PYG{o}{+} \PYG{n}{a}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{dh\PYGZus{}c\PYGZus{}dzc}
\end{sphinxVerbatim}

\sphinxAtStartPar
Likewise we can construct an ingredient to generate the gradient of the quantum\sphinxhyphen{}classical Hamiltonian with respect to the conjugate \sphinxtitleref{z} coordinate.
In many cases this requires the calculation of a sparse tensor and so QC Lab assumes that it is in terms of indices, nonzero elements, and a shape,
\begin{equation*}
\begin{split}\left\langle i\left\vert \frac{\partial \hat{H}_{\mathrm{q-c}}}{\partial z^{*}_{\alpha}}\right\vert j \right\rangle = (-1)^{i}\frac{g_{\alpha}}{\sqrt{2mh_{\alpha}}}\delta_{ij}\end{split}
\end{equation*}
\sphinxAtStartPar
which can be implemented as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}

    \PYG{n}{recalculate} \PYG{o}{=} \PYG{k+kc}{False}
    \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{batch\PYGZus{}size}\PYG{p}{:}
            \PYG{n}{recalculate} \PYG{o}{=} \PYG{k+kc}{True}

    \PYG{k}{if} \PYG{p}{(}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o+ow}{is} \PYG{k+kc}{None}
        \PYG{o+ow}{or} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o+ow}{is} \PYG{k+kc}{None}
        \PYG{o+ow}{or} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o+ow}{is} \PYG{k+kc}{None}
        \PYG{o+ow}{or} \PYG{n}{recalculate}
    \PYG{p}{)}\PYG{p}{:}

        \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}
        \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
        \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{A}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
        \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{g} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
        \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{inds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{mels} \PYG{o}{=} \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{n}{inds}\PYG{p}{]}
        \PYG{n}{shape} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o}{=} \PYG{n}{inds}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o}{=} \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{n}{inds}\PYG{p}{]}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o}{=} \PYG{n}{shape}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{inds} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds}
        \PYG{n}{mels} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels}
        \PYG{n}{shape} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape}
    \PYG{k}{return} \PYG{n}{inds}\PYG{p}{,} \PYG{n}{mels}\PYG{p}{,} \PYG{n}{shape}
\end{sphinxVerbatim}

\sphinxAtStartPar
An important feature of the above implementation is that it checks if the gradient has already been calculated. This is convenient because the gradient is a constant
and so does not need to be recalculated every time the ingredient is called. As a consequence, however, we need to initialize the gradient to \sphinxtitleref{None} in the model class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Include initialization of the model as done above.}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o}{=} \PYG{k+kc}{None}
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that a flag can be included to prevent the RK4 solver in QC Lab from recalculating the quantum\sphinxhyphen{}classical forces (i.e., the expectation value of \sphinxtitleref{dh\_qc\_dzc}):
\sphinxtitleref{sim.model.linear\_h\_qc = True}.


\paragraph{Classical Initialization}
\label{\detokenize{user_guide/model_dev:classical-initialization}}
\sphinxAtStartPar
By default QC Lab assumes that a model’s initial \sphinxtitleref{z} coordinate is sampled from a Boltzmann distribution with a thermal quantum given by \sphinxtitleref{kBT} and attempts to sample a
Boltzmann distribution given the classical Hamiltonian. This is in practice making a number of assumptions, notably that all the \sphinxtitleref{z} coordinates are uncoupled from
one another in the classical Hamiltonian.

\sphinxAtStartPar
This is accomplished by defining an ingredient called \sphinxtitleref{init\_classical} which has the following form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{init\PYGZus{}classical}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{del} \PYG{n}{model}\PYG{p}{,} \PYG{n}{parameters}
    \PYG{n}{seed} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{seed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)}
    \PYG{n}{kBT} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{kBT}
    \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
    \PYG{n}{out} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{s}\PYG{p}{,} \PYG{n}{seed\PYGZus{}value} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{n}{seed\PYGZus{}value}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Calculate the standard deviations for q and p.}
        \PYG{n}{std\PYGZus{}q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{kBT} \PYG{o}{/} \PYG{p}{(}\PYG{n}{m} \PYG{o}{*} \PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{std\PYGZus{}p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{m} \PYG{o}{*} \PYG{n}{kBT}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Generate random q and p values.}
        \PYG{n}{q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}
            \PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{n}{std\PYGZus{}q}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates}
        \PYG{p}{)}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}
            \PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{n}{std\PYGZus{}p}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates}
        \PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Calculate the complex\PYGZhy{}valued classical coordinate.}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{h} \PYG{o}{*} \PYG{n}{m} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{q} \PYG{o}{+} \PYG{l+m+mf}{1.0}\PYG{n}{j} \PYG{o}{*} \PYG{p}{(}\PYG{n}{p} \PYG{o}{/} \PYG{p}{(}\PYG{n}{h} \PYG{o}{*} \PYG{n}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{out}\PYG{p}{[}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=} \PYG{n}{z}
    \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\sphinxAtStartPar
The full code for the \sphinxtitleref{UpgradedSpinBoson} model is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{UpgradedSpinBoson}\PYG{p}{(}\PYG{n}{Model}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{constants} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{constants} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants} \PYG{o}{=} \PYG{p}{\PYGZob{}}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{temp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{W}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.1}\PYG{p}{,}
            \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l\PYGZus{}reorg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.02} \PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boson\PYGZus{}mass}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mi}{1}
        \PYG{p}{\PYGZcb{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o}{=} \PYG{k+kc}{None}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{linear\PYGZus{}h\PYGZus{}qc} \PYG{o}{=} \PYG{k+kc}{True}
        \PYG{n+nb}{super}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}model}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{char\PYGZus{}freq} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{W}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{boson\PYGZus{}mass} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
            \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w} \PYG{o}{=} \PYG{n}{char\PYGZus{}freq} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{tan}\PYG{p}{(}
            \PYG{p}{(}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{num\PYGZus{}bosons}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.5}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}
        \PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} The following constants are required by QC Lab}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates} \PYG{o}{=} \PYG{n}{num\PYGZus{}bosons}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}quantum\PYGZus{}states} \PYG{o}{=} \PYG{l+m+mi}{2}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass} \PYG{o}{=} \PYG{n}{boson\PYGZus{}mass} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{ones}\PYG{p}{(}\PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initialize the constants for the classical Hamiltonian.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{w} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency} \PYG{o}{=} \PYG{n}{w}


    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initialize the constants for the quantum\PYGZhy{}classical coupling Hamiltonian.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}
        \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{w} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{l\PYGZus{}reorg} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{g} \PYG{o}{=} \PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{l\PYGZus{}reorg} \PYG{o}{/} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{        }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{        Initialize the constants for the quantum Hamiltonian. None are required in this case.}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{initialization\PYGZus{}functions} \PYG{o}{=} \PYG{p}{[}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}model}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{,}
        \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{,}
    \PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf}{h\PYGZus{}q}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{parameters}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{)}
        \PYG{n}{E} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{E}
        \PYG{n}{V} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{V}
        \PYG{n}{h\PYGZus{}q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
        \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{E}
        \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{E}
        \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{V}
        \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{V}
        \PYG{k}{return} \PYG{n}{h\PYGZus{}q}

    \PYG{k}{def} \PYG{n+nf}{h\PYGZus{}qc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
        \PYG{n}{g} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
        \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
        \PYG{n}{h\PYGZus{}qc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
        \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}
            \PYG{n}{g} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{z} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
        \PYG{p}{)}
        \PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{h\PYGZus{}qc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{h\PYGZus{}qc}

    \PYG{k}{def} \PYG{n+nf}{h\PYGZus{}c}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}

        \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}\PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{newaxis}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
        \PYG{n}{q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
        \PYG{n}{h\PYGZus{}c} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{p}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{m}\PYG{p}{)} \PYG{o}{+} \PYG{n}{m} \PYG{o}{*} \PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{q}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{h\PYGZus{}c}

    \PYG{k}{def} \PYG{n+nf}{dh\PYGZus{}c\PYGZus{}dzc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
        \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}
        \PYG{n}{a} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}
            \PYG{p}{(}\PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{h}
        \PYG{p}{)}
        \PYG{n}{b} \PYG{o}{=} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}
            \PYG{p}{(}\PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{/} \PYG{n}{h}\PYG{p}{)} \PYG{o}{+} \PYG{n}{h}
        \PYG{p}{)}
        \PYG{n}{dh\PYGZus{}c\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{n}{z} \PYG{o}{+} \PYG{n}{a}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{dh\PYGZus{}c\PYGZus{}dzc}

    \PYG{k}{def} \PYG{n+nf}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{z} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
            \PYG{k}{assert} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{==} \PYG{n}{batch\PYGZus{}size}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}

        \PYG{n}{recalculate} \PYG{o}{=} \PYG{k+kc}{False}
        \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
            \PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{batch\PYGZus{}size}\PYG{p}{:}
                \PYG{n}{recalculate} \PYG{o}{=} \PYG{k+kc}{True}

        \PYG{k}{if} \PYG{p}{(}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o+ow}{is} \PYG{k+kc}{None}
            \PYG{o+ow}{or} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o+ow}{is} \PYG{k+kc}{None}
            \PYG{o+ow}{or} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o+ow}{is} \PYG{k+kc}{None}
            \PYG{o+ow}{or} \PYG{n}{recalculate}
        \PYG{p}{)}\PYG{p}{:}

            \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
            \PYG{n}{g} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{spin\PYGZus{}boson\PYGZus{}coupling}
            \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
            \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{A}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
            \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n}{g} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{]}
            \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,} \PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}
            \PYG{n}{inds} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{)}
            \PYG{n}{mels} \PYG{o}{=} \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{n}{inds}\PYG{p}{]}
            \PYG{n}{shape} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{(}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{)}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o}{=} \PYG{n}{inds}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o}{=} \PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc}\PYG{p}{[}\PYG{n}{inds}\PYG{p}{]}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o}{=} \PYG{n}{shape}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{inds} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds}
            \PYG{n}{mels} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels}
            \PYG{n}{shape} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape}
        \PYG{k}{return} \PYG{n}{inds}\PYG{p}{,} \PYG{n}{mels}\PYG{p}{,} \PYG{n}{shape}

    \PYG{k}{def} \PYG{n+nf}{init\PYGZus{}classical}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{del} \PYG{n}{model}\PYG{p}{,} \PYG{n}{parameters}
        \PYG{n}{seed} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{seed}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k+kc}{None}\PYG{p}{)}
        \PYG{n}{kBT} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{kBT}
        \PYG{n}{h} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
        \PYG{n}{w} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency}
        \PYG{n}{m} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}mass}
        \PYG{n}{out} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{,} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{s}\PYG{p}{,} \PYG{n}{seed\PYGZus{}value} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{seed}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{(}\PYG{n}{seed\PYGZus{}value}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Calculate the standard deviations for q and p.}
            \PYG{n}{std\PYGZus{}q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{kBT} \PYG{o}{/} \PYG{p}{(}\PYG{n}{m} \PYG{o}{*} \PYG{p}{(}\PYG{n}{w}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{std\PYGZus{}p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{m} \PYG{o}{*} \PYG{n}{kBT}\PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Generate random q and p values.}
            \PYG{n}{q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}
                \PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{n}{std\PYGZus{}q}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates}
            \PYG{p}{)}
            \PYG{n}{p} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}
                \PYG{n}{loc}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{scale}\PYG{o}{=}\PYG{n}{std\PYGZus{}p}\PYG{p}{,} \PYG{n}{size}\PYG{o}{=}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{num\PYGZus{}classical\PYGZus{}coordinates}
            \PYG{p}{)}
            \PYG{c+c1}{\PYGZsh{} Calculate the complex\PYGZhy{}valued classical coordinate.}
            \PYG{n}{z} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{h} \PYG{o}{*} \PYG{n}{m} \PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{q} \PYG{o}{+} \PYG{l+m+mf}{1.0}\PYG{n}{j} \PYG{o}{*} \PYG{p}{(}\PYG{n}{p} \PYG{o}{/} \PYG{p}{(}\PYG{n}{h} \PYG{o}{*} \PYG{n}{m}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{out}\PYG{p}{[}\PYG{n}{s}\PYG{p}{]} \PYG{o}{=} \PYG{n}{z}
        \PYG{k}{return} \PYG{n}{out}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The upgraded model still relies on numerical hopping for FSSH simulations. Below we will see how to use the analytic hopping ingredient for the harmonic oscillator.
\end{sphinxadmonition}


\paragraph{Using Built\sphinxhyphen{}in Ingredients}
\label{\detokenize{user_guide/model_dev:using-built-in-ingredients}}
\sphinxAtStartPar
QC Lab comes with a number of built\sphinxhyphen{}in ingredients that can be used to construct a model rather than writing ingredients from scratch like above. These ingredients can be imported
from \sphinxtitleref{qc\_lab.ingredients} and are documented in the {\hyperref[\detokenize{software_reference/ingredients/ingredients:ingredients}]{\sphinxcrossref{\DUrole{std}{\DUrole{std-ref}{Ingredients}}}}} section.

\sphinxAtStartPar
For the present example, we can avoid writing our own optimized ingredients and simply add the available built\sphinxhyphen{}in ingredients to the model.

\sphinxAtStartPar
First let’s load the quantum Hamiltonian as the built\sphinxhyphen{}in two\sphinxhyphen{}level system Hamiltonian:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{ingredients} \PYG{k}{as} \PYG{n+nn}{ingredients}
\PYG{n}{model} \PYG{o}{=} \PYG{n}{MinimalSpinBoson}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{h\PYGZus{}q} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}h\PYGZus{}q}
\end{sphinxVerbatim}

\sphinxAtStartPar
We will also need a new initialization function to interface with the constants used by the built\sphinxhyphen{}in ingredient:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the quantum Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}a} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}c} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
Let’s then add the ingredient and initialization function to the model class:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{h\PYGZus{}q} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}h\PYGZus{}q}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q} \PYG{o}{=} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}
\PYG{c+c1}{\PYGZsh{} also update the list of initialization functions}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{swap\PYGZus{}initialization\PYGZus{}function}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
here, we used the \sphinxtitleref{swap\_initialization\_function} method to update the list of initialization functions. This is a convenience function that will swap out the initialization function
with a given name. In this case, we are swapping out the \sphinxtitleref{initialize\_constants\_h\_q} function with the new one we just defined.

\sphinxAtStartPar
Next we can load the classical Hamiltonian as the built\sphinxhyphen{}in harmonic oscillator Hamiltonian and update the initialization function like before:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the classical Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency} \PYG{o}{=} \PYG{n}{w}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{h\PYGZus{}c} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}h\PYGZus{}c}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c} \PYG{o}{=} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{swap\PYGZus{}initialization\PYGZus{}function}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can also load analytic gradients for the classical Hamiltonian (which relies
on the same constants has the classical Hamiltonian).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dh\PYGZus{}c\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}dh\PYGZus{}c\PYGZus{}dzc}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we can load the quantum\sphinxhyphen{}classical Hamiltonian and its gradient. We will use the built\sphinxhyphen{}in ingredient \sphinxtitleref{diagonal\_linear\_h\_qc} which is a generic
quantum\sphinxhyphen{}classical Hamiltonian that linearly couples classical coordinates to the diagonal of the Hamiltonian. As a result we must specify a set of
couplings to ensure that each coordinate is coupled to the correct entry of the diagonal.

\sphinxAtStartPar
Then we can load in the built\sphinxhyphen{}in classical initialization ingredient which samples the Boltzmann distribution for the harmonic oscillator Hamiltonian.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{init\PYGZus{}classical} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}init\PYGZus{}classical}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next, we can load an ingredient that executes the hopping procedure of the FSSH algorithm according to a harmonic oscillator. This will improve the
performance of the FSSH algorithm.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{hop\PYGZus{}function} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}boltzmann\PYGZus{}init\PYGZus{}classical}
\end{sphinxVerbatim}

\sphinxAtStartPar
Lastly, we can add a flag to the model class that enables the RK4 solver in QC Lab to avoid recalculating gradients of the quantum\sphinxhyphen{}classical Hamiltonian
(which is a constant if the quantum\sphinxhyphen{}classical Hamiltonian is linear in \sphinxtitleref{z}).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{linear\PYGZus{}h\PYGZus{}qc} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\sphinxAtStartPar
The resulting model class is now fully upgraded and can be used to simulate the spin\sphinxhyphen{}boson model with significantly improved performance.

\sphinxAtStartPar
The full code for upgrading the \sphinxtitleref{MinimalSpinBoson} using built\sphinxhyphen{}in ingredients is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model} \PYG{o}{=} \PYG{n}{MinimalSpinBoson}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{h\PYGZus{}q} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}h\PYGZus{}q}

\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the quantum Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}a} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}b} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{E}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}c} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}
        \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{V}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}d} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q} \PYG{o}{=} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}
\PYG{c+c1}{\PYGZsh{} also update the list of initialization functions}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{swap\PYGZus{}initialization\PYGZus{}function}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}q}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the classical Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}frequency} \PYG{o}{=} \PYG{n}{w}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{h\PYGZus{}c} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}h\PYGZus{}c}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c} \PYG{o}{=} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{swap\PYGZus{}initialization\PYGZus{}function}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}c}\PYG{p}{)}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{dh\PYGZus{}c\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}dh\PYGZus{}c\PYGZus{}dzc}

\PYG{k}{def} \PYG{n+nf}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{(}\PYG{n}{model}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Initialize the constants for the quantum\PYGZhy{}classical coupling Hamiltonian.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{num\PYGZus{}bosons} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{l\PYGZus{}reorg} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{l\PYGZus{}reorg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{m} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{boson\PYGZus{}mass}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{h} \PYG{o}{=} \PYG{p}{(}
        \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{classical\PYGZus{}coordinate\PYGZus{}weight}
    \PYG{p}{)}
    \PYG{n}{w} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{w}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{diagonal\PYGZus{}linear\PYGZus{}coupling} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{diagonal\PYGZus{}linear\PYGZus{}coupling}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}
        \PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{l\PYGZus{}reorg} \PYG{o}{/} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{diagonal\PYGZus{}linear\PYGZus{}coupling}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}
        \PYG{o}{\PYGZhy{}}\PYG{n}{w} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{l\PYGZus{}reorg} \PYG{o}{/} \PYG{n}{num\PYGZus{}bosons}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{/} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{m} \PYG{o}{*} \PYG{n}{h}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{h\PYGZus{}qc} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{diagonal\PYGZus{}linear\PYGZus{}h\PYGZus{}qc}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{diagonal\PYGZus{}linear\PYGZus{}dh\PYGZus{}qc\PYGZus{}dzc}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}inds} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}mels} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{dh\PYGZus{}qc\PYGZus{}dzc\PYGZus{}shape} \PYG{o}{=} \PYG{k+kc}{None}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{swap\PYGZus{}initialization\PYGZus{}function}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{initialize\PYGZus{}constants\PYGZus{}h\PYGZus{}qc}\PYG{p}{)}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{init\PYGZus{}classical} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}boltzmann\PYGZus{}init\PYGZus{}classical}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{hop\PYGZus{}function} \PYG{o}{=} \PYG{n}{ingredients}\PYG{o}{.}\PYG{n}{harmonic\PYGZus{}oscillator\PYGZus{}hop\PYGZus{}function}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{linear\PYGZus{}h\PYGZus{}qc} \PYG{o}{=} \PYG{k+kc}{True}
\end{sphinxVerbatim}

\sphinxstepscope


\subsection{Default Behavior}
\label{\detokenize{user_guide/defaults:default-behavior}}\label{\detokenize{user_guide/defaults:defaults}}\label{\detokenize{user_guide/defaults::doc}}

\subsubsection{Default Simulation Settings}
\label{\detokenize{user_guide/defaults:default-simulation-settings}}
\sphinxAtStartPar
By default QC Lab uses the following settings in the simulation object. These settings can be adjusted by changing the values in the \sphinxtitleref{sim} object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{var} \PYG{o}{=} \PYG{n}{val} \PYG{c+c1}{\PYGZsh{} Can change the value of a setting like this}

\PYG{c+c1}{\PYGZsh{} or by passing the setting directly to the simulation object.}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{var}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{val}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Default Simulation Settings}\label{\detokenize{user_guide/defaults:id1}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default Value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{num\_trajs}
&
\sphinxAtStartPar
The total number of trajectories to run.
&
\sphinxAtStartPar
10
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{batch\_size}
&
\sphinxAtStartPar
The (maximum) number of trajectories to run simultaneously.
&
\sphinxAtStartPar
1
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{tmax}
&
\sphinxAtStartPar
The total time of each trajectory.
&
\sphinxAtStartPar
10
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{dt}
&
\sphinxAtStartPar
The timestep used for executing the update recipe (the dynamics propagation).
&
\sphinxAtStartPar
0.01
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{dt\_output}
&
\sphinxAtStartPar
The timestep used for executing the output recipe (the calculation of observables).
&
\sphinxAtStartPar
0.1
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
QC Lab expects that the total time of the simulation is an integer multiple of the output timestep \sphinxtitleref{dt\_output}, which must also be an integer multiple
of the propagation timestep \sphinxtitleref{dt}.
\end{sphinxadmonition}


\subsubsection{Default Model Attributes}
\label{\detokenize{user_guide/defaults:default-model-attributes}}
\sphinxAtStartPar
For minimal models where only the Hamiltonian of the system is defined in the Model class, QC Lab employs numerical methods to carry out
particular steps in the dynamics algorithms. This page describes those default actions and also the constants that can be used to manipulate them.
Because they are formally treated as model ingredients they  have the same ingredient format discussed in the model development guide.

\sphinxAtStartPar
All of the constants below can be set by adjusting their value in the \sphinxtitleref{model.constants} object, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{constants}\PYG{o}{.}\PYG{n}{default\PYGZus{}value} \PYG{o}{=} \PYG{c+c1}{\PYGZsh{} fix the value of the constant \PYGZsq{}default\PYGZus{}value\PYGZsq{}}
\end{sphinxVerbatim}


\paragraph{Initialization of classical coordinates}
\label{\detokenize{user_guide/defaults:initialization-of-classical-coordinates}}\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!sim.model.init\_classical()@\spxentry{sim.model.init\_classical()}}\index{sim.model.init\_classical()@\spxentry{sim.model.init\_classical()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/defaults:sim.model.init_classical}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{sim.model.}}\sphinxbfcode{\sphinxupquote{init\_classical}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{n}{seed}\DUrole{o}{=}\DUrole{default_value}{seed}}}
{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{seed}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{batch\_size}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dtype=int}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} List of seeds used to initialize random numbers.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Initial complex\sphinxhyphen{}valued classical coordinate.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray((batch\_size, sim.model.constants.num\_classical\_coordinates), dtype=complex)

\end{description}\end{quote}

\end{fulllineitems}


\sphinxAtStartPar
By default, QC Lab uses a Markov\sphinxhyphen{}chain Monte Carlo implementation of the Metropolis\sphinxhyphen{}Hastings algorithm to sample a Boltzmann distribution corresponding to
\sphinxtitleref{sim.model.h\_c} at the thermal quantum \sphinxtitleref{sim.model.constants.kBT}. We encourage caution and further validation before using it on arbitrary classical
potentials as fine\sphinxhyphen{}tuning of the algorithm parameters may be required to obtain reliable results.

\sphinxAtStartPar
The implementation utilizes a single random walker in \sphinxtitleref{sim.model.constants.num\_classical\_coordinates} dimensions or \sphinxtitleref{sim.model.constants.num\_classical\_coordinates}
walkers each in one dimension (depending on if \sphinxtitleref{mcmc\_h\_c\_separable==True}) and evolves the walkers from the initial point \sphinxtitleref{mcmc\_init\_z} by sampling a Gaussian distribution with
a standard deviation \sphinxtitleref{mcmc\_std} for \sphinxtitleref{mcmc\_burn\_in\_size} steps. It then evolves the walkers another \sphinxtitleref{mcmc\_sample\_size} steps to collect a distribution of initial coordinates from which
the required number of initial conditions are drawn uniformly. At a minimum, one should ensure that \sphinxtitleref{mcmc\_sample\_size} is large enough to ensure a full exploration of the phase\sphinxhyphen{}space.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabular}[t]{\X{30}{130}\X{80}{130}\X{20}{130}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{mcmc\_burn\_in\_size}
&
\sphinxAtStartPar
Number of burn\sphinxhyphen{}in steps.
&
\sphinxAtStartPar
10000
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{mcmc\_sample\_size}
&
\sphinxAtStartPar
Number of samples to collect from which initial conditions are drawn. To ensure a full exploration of the phase\sphinxhyphen{}space this should be as large as practical.
&
\sphinxAtStartPar
100000
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{mcmc\_h\_c\_separable}
&
\sphinxAtStartPar
A boolean indicating if the classical Hamiltonian is separable into independent terms for each coordinate. If True each coordinate will be independently sampled improving the performance of the algorithm. If False the sampling will occur in the full dimensional space.
&
\sphinxAtStartPar
True
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{mcmc\_init\_z}
&
\sphinxAtStartPar
The initial coordinate that the random walker is initialized at.
&
\sphinxAtStartPar
A point in the interval (0,1) for both real and imaginary parts in each coordinate. (This is deterministically chosen for reproducability).
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{mcmc\_std}
&
\sphinxAtStartPar
The standard deviation of the Gaussian used to generate the random walk.
&
\sphinxAtStartPar
1
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Classical Hamiltonian gradients}
\label{\detokenize{user_guide/defaults:classical-hamiltonian-gradients}}\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!sim.model.dh\_c\_dzc()@\spxentry{sim.model.dh\_c\_dzc()}}\index{sim.model.dh\_c\_dzc()@\spxentry{sim.model.dh\_c\_dzc()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/defaults:sim.model.dh_c_dzc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{sim.model.}}\sphinxbfcode{\sphinxupquote{dh\_c\_dzc}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{z}}}
{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{batch\_size}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{sim.model.constants.num\_classical\_coordinates}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dtype=complex}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} complex\sphinxhyphen{}valued classical coordinate.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Gradient of the classical Hamiltonian.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray((batch\_size, sim.model.constants.num\_classical\_coordinates), dtype=complex)

\end{description}\end{quote}

\end{fulllineitems}


\sphinxAtStartPar
QC Lab utilizes a finite difference method to calculate the gradient of the classical Hamiltonian.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{dh\_qc\_dzc\_finite\_differences\_delta}
&
\sphinxAtStartPar
Finite difference that each coordinate is varied by.
&
\sphinxAtStartPar
1e\sphinxhyphen{}6
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Quantum\sphinxhyphen{}classical Hamiltonian gradients}
\label{\detokenize{user_guide/defaults:quantum-classical-hamiltonian-gradients}}\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!sim.model.dh\_c\_dzc()@\spxentry{sim.model.dh\_c\_dzc()}}\index{sim.model.dh\_c\_dzc()@\spxentry{sim.model.dh\_c\_dzc()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/defaults:id0}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{sim.model.}}\sphinxbfcode{\sphinxupquote{dh\_c\_dzc}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{z}}}
{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{batch\_size}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{sim.model.constants.num\_classical\_coordinates}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dtype=complex}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} complex\sphinxhyphen{}valued classical coordinate.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Indices of nonzero values

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray((\# of nonzero values, 4), dtype=int)

\sphinxlineitem{Returns}
\sphinxAtStartPar
Values

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray((\# of nonzero values), dtype=complex)

\sphinxlineitem{Returns}
\sphinxAtStartPar
Shape of dense gradient: (batch\_size, sim.model.constants.num\_classical\_coordinates, sim.model.constants.num\_quantum\_states, sim.model.constants.num\_quantum\_states)

\sphinxlineitem{Return type}
\sphinxAtStartPar
Tuple

\end{description}\end{quote}

\end{fulllineitems}


\sphinxAtStartPar
QC Lab utilizes a finite difference method to calculate the gradient of the quantum\sphinxhyphen{}classical Hamiltonian. Unlike that of the
classical Hamiltonian, however, the output is in a sparse format.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{dh\_qc\_dzc\_finite\_differences\_delta}
&
\sphinxAtStartPar
finite difference that each coordinate is varied by.
&
\sphinxAtStartPar
1e\sphinxhyphen{}6
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\paragraph{Surface Hopping Switching Algorithm}
\label{\detokenize{user_guide/defaults:surface-hopping-switching-algorithm}}\index{built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}!sim.model.hop\_function()@\spxentry{sim.model.hop\_function()}}\index{sim.model.hop\_function()@\spxentry{sim.model.hop\_function()}!built\sphinxhyphen{}in function@\spxentry{built\sphinxhyphen{}in function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{user_guide/defaults:sim.model.hop_function}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{sim.model.}}\sphinxbfcode{\sphinxupquote{hop\_function}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{n}{z}\DUrole{o}{=}\DUrole{default_value}{z}}\sphinxparamcomma \sphinxparam{\DUrole{n}{delta\_z}\DUrole{o}{=}\DUrole{default_value}{delta\_z}}\sphinxparamcomma \sphinxparam{\DUrole{n}{ev\_diff}\DUrole{o}{=}\DUrole{default_value}{ev\_diff}}}
{}
\pysigstopsignatures\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{sim.model.constants.num\_classical\_coordinates}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dtype=complex}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Complex\sphinxhyphen{}valued classical coordinate (in a single trajectory).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta\_z}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{sim.model.constants.num\_classical\_coordinates}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{dtype=complex}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Rescaling direction.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ev\_diff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Energy difference between final and initial surface (final \sphinxhyphen{} initial).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Rescaled coordinate.

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray(sim.model.constants.num\_classical\_coordinates, dtype=complex)

\sphinxlineitem{Returns}
\sphinxAtStartPar
True or False depending on if a hop happened.

\sphinxlineitem{Return type}
\sphinxAtStartPar
Bool.

\end{description}\end{quote}

\end{fulllineitems}


\sphinxAtStartPar
QC Lab implements a numerical method to find the scalar factor (gamma) required to rescale classical coordinates in the surface hopping algorithm. It works by constructing a uniform grid with
\sphinxtitleref{numerical\_fssh\_hop\_num\_points} points
from negative to positive and determines the point at which energy is conserved the closest. It then recenters the
grid at that point and reduces the range by 0.5 and once again searches for the point at which energy is conserved the closest. It repeats that step for \sphinxtitleref{numerical\_fssh\_hop\_max\_iter}
iterations or until the energy difference is less than \sphinxtitleref{numerical\_fssh\_hop\_threshold}. If the energy it reaches is less than the threshold then the hop is
accepted, if it is greater then the hop is rejected.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Description
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Default value
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxtitleref{numerical\_fssh\_hop\_gamma\_range}
&
\sphinxAtStartPar
Interval from minus to positive over which gamma is initially sampled.
&
\sphinxAtStartPar
5
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{numerical\_fssh\_hop\_num\_points}
&
\sphinxAtStartPar
The number of points on the grid used to sample gamma.
&
\sphinxAtStartPar
10
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{numerical\_fssh\_hop\_threshold}
&
\sphinxAtStartPar
The threshold used to determine if a hop is conserving energy at a given gamma.
&
\sphinxAtStartPar
1e\sphinxhyphen{}6
\\
\sphinxhline
\sphinxAtStartPar
\sphinxtitleref{numerical\_fssh\_hop\_max\_iter}
&
\sphinxAtStartPar
The maximum number of iterations before a search for gamma is halted.
&
\sphinxAtStartPar
20
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\subsection{Algorithm Development}
\label{\detokenize{user_guide/algorithm_dev:algorithm-development}}\label{\detokenize{user_guide/algorithm_dev:algorithm-dev}}\label{\detokenize{user_guide/algorithm_dev::doc}}
\sphinxAtStartPar
In this guide, we will discuss how to make in\sphinxhyphen{}place modifications to Algorithms. Algorithm development is a
more advanced topic and requires a good understanding of the underlying steps of the algorithm so we will not
go into detail (in this guide) about how to develop a new algorithm from scratch. Instead, we will focus
on making changes to existing algorithms.

\sphinxAtStartPar
Before we proceed, let’s discuss the structure of an algorithm in QC Lab. An algorithm in QC Lab is a Python
class that inherits from the \sphinxtitleref{Algorithm} class in the \sphinxtitleref{qc\_lab.algorithm} module. The built\sphinxhyphen{}in algorithms are
found in the \sphinxtitleref{qc\_lab.algorithms} module and presently contain \sphinxtitleref{qc\_lab.algorithms.MeanField} and
\sphinxtitleref{qc\_lab.algorithms.FewestSwitchesSurfaceHopping}.

\sphinxAtStartPar
We can start by importing the \sphinxtitleref{MeanField} algorithm from the \sphinxtitleref{qc\_lab.algorithms} module:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{algorithms} \PYG{k+kn}{import} \PYG{n}{MeanField}
\end{sphinxVerbatim}

\sphinxAtStartPar
Each algorithm consists of three lists of functions which are referred to as “recipes”, the functions themselves are
referred to as “tasks”.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} the initialization recipe}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{initialization\PYGZus{}recipe}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the update recipe}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{update\PYGZus{}recipe}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} the output recipe}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{output\PYGZus{}recipe}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
As the name implies, the \sphinxtitleref{initialization\_recipe} initializes all the variables required for the algorithm. The \sphinxtitleref{update\_recipe}
updates the variables at each time step, and the \sphinxtitleref{output\_recipe} is used to output the results of the algorithm.

\sphinxAtStartPar
In addition to the recipes, a list of variable names is needed to specify which variables the algorithm will store in the Data object.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} the variables that the algorithm will store}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{output\PYGZus{}variables}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Adding output obvservables}
\label{\detokenize{user_guide/algorithm_dev:adding-output-obvservables}}
\sphinxAtStartPar
To add an additional variable to the output of an algorithm we must define a task that calculates the variable and add it to the output recipe.


\paragraph{Linear response functions}
\label{\detokenize{user_guide/algorithm_dev:linear-response-functions}}
\sphinxAtStartPar
For example, let’s calculate a linear response function that can be used to calculate the absorption spectrum of a system. Mathematically we will calculate
\begin{equation*}
\begin{split}R(t) = \langle \psi(0) \vert \psi(t)\rangle\end{split}
\end{equation*}
\sphinxAtStartPar
where \(\vert \psi(t)\rangle\) is the diabatic wavefunction at time \(t\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{update\PYGZus{}response\PYGZus{}function}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{state}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} First get the diabatic wavefunction.}
    \PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db}
    \PYG{c+c1}{\PYGZsh{} If we are at the first timestep we can store the diabatic wavefunction in the parameters object}
    \PYG{k}{if} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{t\PYGZus{}ind} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{parameters}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db\PYGZus{}0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{n}{wf\PYGZus{}db}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Next calculate the response function and store it in the state object.}
    \PYG{n}{state}\PYG{o}{.}\PYG{n}{response\PYGZus{}function} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{parameters}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db\PYGZus{}0}\PYG{p}{)} \PYG{o}{*} \PYG{n}{wf\PYGZus{}db}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{state}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we can add this task to the output recipe.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{output\PYGZus{}recipe}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{update\PYGZus{}response\PYGZus{}function}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally we can add the relevant variable name to the output\_variables list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{output\PYGZus{}variables}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{response\PYGZus{}function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can then run a simulation and calculate the corresponding spectral function,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{SpinBoson}

\PYG{c+c1}{\PYGZsh{} instantiate a simulation}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default simulation settings: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{default\PYGZus{}settings}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} change settings to customize simulation}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{num\PYGZus{}trajs} \PYG{o}{=} \PYG{l+m+mi}{1000}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{250}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mi}{50}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}

\PYG{c+c1}{\PYGZsh{} instantiate a model}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{SpinBoson}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l\PYGZus{}reorg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+m+mf}{0.2}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default model constants: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} print out default constants}

\PYG{c+c1}{\PYGZsh{} instantiate an algorithm}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default algorithm settings: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm}\PYG{o}{.}\PYG{n}{default\PYGZus{}settings}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} print out default settings}



\PYG{c+c1}{\PYGZsh{} define an initial diabatic wavefunction}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} run the simulation}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{parallel\PYGZus{}driver\PYGZus{}multiprocessing}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{num\PYGZus{}tasks}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} plot the data.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calculated quantities:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dic}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{response\PYGZus{}function} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{response\PYGZus{}function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{time} \PYG{o}{=} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{tdat\PYGZus{}output}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{response\PYGZus{}function}\PYG{p}{)}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{R(t)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{response function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{roll}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{fft}\PYG{o}{.}\PYG{n}{fft}\PYG{p}{(}\PYG{n}{response\PYGZus{}function}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{time}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{freq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{absorbance}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Adiabatic populations}
\label{\detokenize{user_guide/algorithm_dev:adiabatic-populations}}
\sphinxAtStartPar
Next, let’s calculate the adiabatic populations of the system as is sometimes done in scattering problems. Obviously these populations
will only have a well\sphinxhyphen{}defined meaning in regimes with no nonadiabatic coupling.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{update\PYGZus{}adiabatic\PYGZus{}populations}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{state}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} First get the Hamiltonian and calculate its eigenvalues and eigenvectors.}
    \PYG{n}{H} \PYG{o}{=} \PYG{n}{state}\PYG{o}{.}\PYG{n}{h\PYGZus{}quantum} \PYG{c+c1}{\PYGZsh{} this is the quantum plus quantum\PYGZhy{}classical Hamiltonian.}
    \PYG{c+c1}{\PYGZsh{} Next obtain its eigenvalues and eigenvectors.}
    \PYG{n}{evals}\PYG{p}{,} \PYG{n}{evecs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eigh}\PYG{p}{(}\PYG{n}{H}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Now calculate the adiabatic wavefunction.}
    \PYG{n}{wf\PYGZus{}adb} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{einsum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tji,tj\PYGZhy{}\PYGZgt{}ti}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{n}{evecs}\PYG{p}{)}\PYG{p}{,} \PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} Finally calculate the populations (note that we do not sum over the batch, this is done internally by QC Lab).}
    \PYG{n}{pops\PYGZus{}adb} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{wf\PYGZus{}adb}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{c+c1}{\PYGZsh{} Store the populations in the state object.}
    \PYG{n}{state}\PYG{o}{.}\PYG{n}{pops\PYGZus{}adb} \PYG{o}{=} \PYG{n}{pops\PYGZus{}adb}
    \PYG{k}{return} \PYG{n}{parameters}\PYG{p}{,} \PYG{n}{state}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next we can add this task to the output recipe.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{output\PYGZus{}recipe}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{update\PYGZus{}adiabatic\PYGZus{}populations}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally we can add the relevant variable name to the output\_variables list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MeanField}\PYG{o}{.}\PYG{n}{output\PYGZus{}variables}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pops\PYGZus{}adb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
We can then run a simulation and plot the populations. Note that since the spin\sphinxhyphen{}boson model is always in a coupling regime these populations will not have a well\sphinxhyphen{}defined meaning.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab} \PYG{k+kn}{import} \PYG{n}{Simulation}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{dynamics} \PYG{k+kn}{import} \PYG{n}{serial\PYGZus{}driver}
\PYG{k+kn}{from} \PYG{n+nn}{qc\PYGZus{}lab}\PYG{n+nn}{.}\PYG{n+nn}{models} \PYG{k+kn}{import} \PYG{n}{SpinBoson}

\PYG{c+c1}{\PYGZsh{} Instantiate a simulation.}
\PYG{n}{sim} \PYG{o}{=} \PYG{n}{Simulation}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default simulation settings: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{default\PYGZus{}settings}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Change settings to customize simulation.}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{num\PYGZus{}trajs} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{tmax} \PYG{o}{=} \PYG{l+m+mi}{25}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{dt} \PYG{o}{=} \PYG{l+m+mf}{0.01}

\PYG{c+c1}{\PYGZsh{} Instantiate a model.}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{model} \PYG{o}{=} \PYG{n}{SpinBoson}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default model constants: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{model}\PYG{o}{.}\PYG{n}{default\PYGZus{}constants}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} print out default constants}

\PYG{c+c1}{\PYGZsh{} Instantiate an algorithm.}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{MeanField}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{default algorithm settings: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{algorithm}\PYG{o}{.}\PYG{n}{default\PYGZus{}settings}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} print out default settings}



\PYG{c+c1}{\PYGZsh{} Define an initial diabatic wavefunction.}
\PYG{n}{sim}\PYG{o}{.}\PYG{n}{state}\PYG{o}{.}\PYG{n}{wf\PYGZus{}db} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Run the simulation.}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{serial\PYGZus{}driver}\PYG{p}{(}\PYG{n}{sim}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data.}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calculated quantities:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dic}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{classical\PYGZus{}energy} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{classical\PYGZus{}energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{quantum\PYGZus{}energy} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quantum\PYGZus{}energy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{populations} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{einsum}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tii\PYGZhy{}\PYGZgt{}ti}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dm\PYGZus{}db}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{adiabatic\PYGZus{}populations} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{real}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{data\PYGZus{}dict}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pops\PYGZus{}adb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{time} \PYG{o}{=} \PYG{n}{sim}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{tdat\PYGZus{}output}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{adiabatic\PYGZus{}populations}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adiabatic state 0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{time}\PYG{p}{,} \PYG{n}{adiabatic\PYGZus{}populations}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adiabatic state 1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{population}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the above code we chose to modify the MeanField class itself rather than an instance of it. This can lead to troublesome
behavior in a Jupyter notebook where the class will not be reloaded if the cell is rerun. Restarting the kernel
will fix this issue. Otherwise one can modify an instance of the class by creating a new instance and modifying it.
\end{sphinxadmonition}


\subsubsection{Modifying algorithm behavior}
\label{\detokenize{user_guide/algorithm_dev:modifying-algorithm-behavior}}
\sphinxAtStartPar
In the same way that we could modify the output recipe, it is possible to modify the initialization and update recipes in the same way.
We will not go into detail on how to do this here but the process is the same as for the output recipe (except there is no output variable in those cases).


\chapter{Software Reference}
\label{\detokenize{index:software-reference}}
\sphinxAtStartPar
A reference guide for QC Lab, documenting all tasks and ingredients available in the software.

\sphinxstepscope


\section{Software Reference}
\label{\detokenize{software_reference/index:software-reference}}\label{\detokenize{software_reference/index:id1}}\label{\detokenize{software_reference/index::doc}}
\sphinxstepscope


\subsection{Ingredients}
\label{\detokenize{software_reference/ingredients/ingredients:ingredients}}\label{\detokenize{software_reference/ingredients/ingredients:id1}}\label{\detokenize{software_reference/ingredients/ingredients::doc}}
\sphinxAtStartPar
Ingredients are methods associated with model classes. A generic ingredient has the form:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ingredient\PYGZus{}name}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Calculate var.}
    \PYG{n}{var} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{k}{return} \PYG{n}{var}
\end{sphinxVerbatim}

\sphinxAtStartPar
For consistency we include all of the arguments even if the ingredient does not use them.
An ingredient that generates the quantum Hamiltonian for a two\sphinxhyphen{}level system might look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{two\PYGZus{}level\PYGZus{}system\PYGZus{}h\PYGZus{}q}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{,} \PYG{n}{parameters}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}\PYG{p}{:}
\PYG{+w}{    }\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Quantum Hamiltonian for a two\PYGZhy{}level system.}

\PYG{l+s+sd}{    Required Constants:}
\PYG{l+s+sd}{        \PYGZhy{} two\PYGZus{}level\PYGZus{}system\PYGZus{}a: Energy of the first level.}
\PYG{l+s+sd}{        \PYGZhy{} two\PYGZus{}level\PYGZus{}system\PYGZus{}b: Energy of the second level.}
\PYG{l+s+sd}{        \PYGZhy{} two\PYGZus{}level\PYGZus{}system\PYGZus{}c: Real part of the coupling between levels.}
\PYG{l+s+sd}{        \PYGZhy{} two\PYGZus{}level\PYGZus{}system\PYGZus{}d: Imaginary part of the coupling between levels.}

\PYG{l+s+sd}{    Keyword Arguments:}
\PYG{l+s+sd}{        \PYGZhy{} batch\PYGZus{}size: (Optional) Number of batches for vectorized computation.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{del} \PYG{n}{model}
    \PYG{k}{if} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{o+ow}{is} \PYG{o+ow}{not} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n}{kwargs}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{batch\PYGZus{}size}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{parameters}\PYG{o}{.}\PYG{n}{seed}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}q} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{complex}\PYG{p}{)}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}a}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}b}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}c} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}d}
    \PYG{n}{h\PYGZus{}q}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}c} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{n}{j} \PYG{o}{*} \PYG{n}{constants}\PYG{o}{.}\PYG{n}{two\PYGZus{}level\PYGZus{}system\PYGZus{}d}
    \PYG{k}{return} \PYG{n}{h\PYGZus{}q}
\end{sphinxVerbatim}

\sphinxAtStartPar
When incorporated directly into the model class (for instance when writing a model class from scratch) one should replace \sphinxtitleref{model} with \sphinxtitleref{self}. See the Model Development section of the User Guide
for a detailed example.

\sphinxAtStartPar
Below we list all of the ingredients available in the current version of QC Lab and group ingredients by the attribute of the model that they pertain to.


\subsubsection{Quantum Hamiltonian}
\label{\detokenize{software_reference/ingredients/ingredients:module-qc_lab.ingredients}}\label{\detokenize{software_reference/ingredients/ingredients:quantum-hamiltonian}}\index{module@\spxentry{module}!qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}}\index{qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}!module@\spxentry{module}}
\sphinxAtStartPar
This file contains ingredient functions for use in Model classes.
\index{nearest\_neighbor\_lattice\_h\_q() (in module qc\_lab.ingredients)@\spxentry{nearest\_neighbor\_lattice\_h\_q()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.nearest_neighbor_lattice_h_q}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{nearest\_neighbor\_lattice\_h\_q}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Quantum Hamiltonian for a nearest\sphinxhyphen{}neighbor lattice.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{num\_quantum\_states}: Number of quantum states (sites).

\item {} 
\sphinxAtStartPar
\sphinxtitleref{nearest\_neighbor\_lattice\_hopping\_energy}: Hopping energy between sites.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{nearest\_neighbor\_lattice\_periodic\_boundary}: Boolean indicating periodic boundary conditions.

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{batch\_size}: (Optional) Number of batches for vectorized computation.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{two\_level\_system\_h\_q() (in module qc\_lab.ingredients)@\spxentry{two\_level\_system\_h\_q()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.two_level_system_h_q}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{two\_level\_system\_h\_q}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Quantum Hamiltonian for a two\sphinxhyphen{}level system.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{two\_level\_system\_a}: Energy of the first level.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{two\_level\_system\_b}: Energy of the second level.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{two\_level\_system\_c}: Real part of the coupling between levels.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{two\_level\_system\_d}: Imaginary part of the coupling between levels.

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{batch\_size}: (Optional) Number of batches for vectorized computation.

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Quantum\sphinxhyphen{}Classical Hamiltonian}
\label{\detokenize{software_reference/ingredients/ingredients:quantum-classical-hamiltonian}}
\sphinxAtStartPar
Ingredients that generate quantum\sphinxhyphen{}classical interaction terms.
\index{module@\spxentry{module}!qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}}\index{qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}!module@\spxentry{module}}\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:module-0}}
\sphinxAtStartPar
This file contains ingredient functions for use in Model classes.
\index{diagonal\_linear\_dh\_qc\_dzc() (in module qc\_lab.ingredients)@\spxentry{diagonal\_linear\_dh\_qc\_dzc()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.diagonal_linear_dh_qc_dzc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{diagonal\_linear\_dh\_qc\_dzc}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Gradient of the diagonal linear quantum\sphinxhyphen{}classical coupling Hamiltonian.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{num\_quantum\_states}: Number of quantum states (sites).

\item {} 
\sphinxAtStartPar
\sphinxtitleref{num\_classical\_coordinates}: Number of classical coordinates

\item {} 
\sphinxAtStartPar
\sphinxtitleref{diagonal\_linear\_coupling}: Array of coupling constants (num\_sites, num\_classical\_coordinates).

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{z}: complex\sphinxhyphen{}valued classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{batch\_size}: (Optional) Number of batches for vectorized computation.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{diagonal\_linear\_h\_qc() (in module qc\_lab.ingredients)@\spxentry{diagonal\_linear\_h\_qc()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.diagonal_linear_h_qc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{diagonal\_linear\_h\_qc}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Diagonal linear quantum\sphinxhyphen{}classical coupling Hamiltonian.

\sphinxAtStartPar
Diagonal elements are given by

\sphinxAtStartPar
\(H_{ii} = \sum_{j} \gamma_{ij} (z_{j} + z_{j}^*)\)
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{num\_quantum\_states}: Number of quantum states (sites).

\item {} 
\sphinxAtStartPar
\sphinxtitleref{num\_classical\_coordinates}: Number of classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{diagonal\_linear\_coupling}: Array of coupling constants (num\_sites, num\_classical\_coordinates).

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{z}: complex\sphinxhyphen{}valued classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{batch\_size}: (Optional) Number of batches for vectorized computation.

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Classical Hamiltonian}
\label{\detokenize{software_reference/ingredients/ingredients:classical-hamiltonian}}
\sphinxAtStartPar
Ingredients that generate classical Hamiltonians.
\index{module@\spxentry{module}!qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}}\index{qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}!module@\spxentry{module}}\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:module-1}}
\sphinxAtStartPar
This file contains ingredient functions for use in Model classes.
\index{harmonic\_oscillator\_dh\_c\_dzc() (in module qc\_lab.ingredients)@\spxentry{harmonic\_oscillator\_dh\_c\_dzc()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.harmonic_oscillator_dh_c_dzc}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{harmonic\_oscillator\_dh\_c\_dzc}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Derivative of the classical harmonic oscillator Hamiltonian with respect to the \sphinxtitleref{z} coordinate.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_weight}: Array of weights for classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{harmonic\_oscillator\_frequency}: Array of harmonic oscillator frequencies.

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{z}: complex\sphinxhyphen{}valued classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{batch\_size}: (Optional) Number of batches for vectorized computation.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{harmonic\_oscillator\_h\_c() (in module qc\_lab.ingredients)@\spxentry{harmonic\_oscillator\_h\_c()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.harmonic_oscillator_h_c}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{harmonic\_oscillator\_h\_c}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Harmonic oscillator classical Hamiltonian function.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_weight}: Array of weights for classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{harmonic\_oscillator\_frequency}: Array of harmonic oscillator frequencies.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_mass}: Array of masses for classical coordinates.

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{z}: complex\sphinxhyphen{}valued classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{batch\_size}: (Optional) Number of batches for vectorized computation.

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Classical Initialization}
\label{\detokenize{software_reference/ingredients/ingredients:classical-initialization}}
\sphinxAtStartPar
Ingredients that initialize the complex\sphinxhyphen{}valued classical coordinates.
\index{module@\spxentry{module}!qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}}\index{qc\_lab.ingredients@\spxentry{qc\_lab.ingredients}!module@\spxentry{module}}\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:module-2}}
\sphinxAtStartPar
This file contains ingredient functions for use in Model classes.
\index{harmonic\_oscillator\_boltzmann\_init\_classical() (in module qc\_lab.ingredients)@\spxentry{harmonic\_oscillator\_boltzmann\_init\_classical()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.harmonic_oscillator_boltzmann_init_classical}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{harmonic\_oscillator\_boltzmann\_init\_classical}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Initialize classical coordinates according to Boltzmann statistics for the harmonic oscillator.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{kBT}: Thermal quantum.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_weight}: Array of weights for classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{harmonic\_oscillator\_frequency}: Array of harmonic oscillator frequencies.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_mass}: Array of masses for classical coordinates.

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{seed}: Array of random seeds for initialization.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{harmonic\_oscillator\_wigner\_init\_classical() (in module qc\_lab.ingredients)@\spxentry{harmonic\_oscillator\_wigner\_init\_classical()}\spxextra{in module qc\_lab.ingredients}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{software_reference/ingredients/ingredients:qc_lab.ingredients.harmonic_oscillator_wigner_init_classical}}
\pysigstartsignatures
\pysiglinewithargsret
{\sphinxcode{\sphinxupquote{qc\_lab.ingredients.}}\sphinxbfcode{\sphinxupquote{harmonic\_oscillator\_wigner\_init\_classical}}}
{\sphinxparam{\DUrole{n}{model}}\sphinxparamcomma \sphinxparam{\DUrole{n}{constants}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parameters}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}
{}
\pysigstopsignatures
\sphinxAtStartPar
Initialize classical coordinates according to the Wigner distribution of the ground state of a harmonic oscillator.
\begin{description}
\sphinxlineitem{Required Constants:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{kBT}: Thermal quantum.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_weight}: Array of weights for classical coordinates.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{harmonic\_oscillator\_frequency}: Array of harmonic oscillator frequencies.

\item {} 
\sphinxAtStartPar
\sphinxtitleref{classical\_coordinate\_mass}: Array of masses for classical coordinates.

\end{itemize}

\sphinxlineitem{Keyword Arguments:}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxtitleref{seed}: Array of random seeds for initialization.

\end{itemize}

\end{description}

\end{fulllineitems}



\chapter{Bibliography}
\label{\detokenize{index:bibliography}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Miyazaki, K.; Krotz, A.; Tempelaar, R. Mixed Quantum\sphinxhyphen{}Classical Dynamics under Arbitrary Unitary Basis Transformations. J. Chem. Theory Comput. 2024, 20 (15), 6500\sphinxhyphen{}6509. \sphinxurl{https://doi.org/10.1021/acs.jctc.4c00555}

\item {} 
\sphinxAtStartPar
Tully, J. C. Mixed Quantum\textendash{}Classical Dynamics. Faraday Discuss. 1998, 110 (0), 407\textendash{}419. \sphinxurl{https://doi.org/10.1039/A801824C}.

\item {} 
\sphinxAtStartPar
Hammes‐Schiffer, S.; Tully, J. C. Proton Transfer in Solution: Molecular Dynamics with Quantum Transitions. J. Chem. Phys. 1994, 101 (6), 4657\textendash{}4667. \sphinxurl{https://doi.org/10.1063/1.467455}.

\item {} 
\sphinxAtStartPar
Tempelaar, R.; Reichman, D. R. Generalization of Fewest\sphinxhyphen{}Switches Surface Hopping for Coherences. The Journal of Chemical Physics 2018, 148 (10), 102309. \sphinxurl{https://doi.org/10.1063/1.5000843}.

\item {} 
\sphinxAtStartPar
Krotz, A.; Provazza, J.; Tempelaar, R. A Reciprocal\sphinxhyphen{}Space Formulation of Mixed Quantum\textendash{}Classical Dynamics. J. Chem. Phys. 2021, 154 (22), 224101. \sphinxurl{https://doi.org/10.1063/5.0053177}.

\item {} 
\sphinxAtStartPar
Fenna, R. E. \& Matthews, B. W. Chlorophyll arrangement in a bacteriochlorophyll protein from Chlorobium limicola. Nature 258, 573\textendash{}577 (1975). \sphinxurl{https://doi.org/10.1038/258573a0}.

\item {} 
\sphinxAtStartPar
Mulvihill, E.; Lenn, K. M.; Gao, X.; Schubert, A.; Dunietz, B. D.; Geva, E. Simulating Energy Transfer Dynamics in the Fenna\textendash{}Matthews\textendash{}Olson Complex via the Modified Generalized Quantum Master Equation. The Journal of Chemical Physics 2021, 154 (20), 204109. \sphinxurl{https://doi.org/10.1063/5.0051101}.

\end{enumerate}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{q}
\item\relax\sphinxstyleindexentry{qc\_lab.ingredients}\sphinxstyleindexpageref{software_reference/ingredients/ingredients:\detokenize{module-2}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}